<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    面经笔记 | ZileWang7的Blog
</title>
<link rel="shortcut icon" href="https://DDC777.github.io/favicon.ico?v=1654850621748">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://DDC777.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://DDC777.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://DDC777.github.io">
                <img class="avatar" src="https://DDC777.github.io/images/avatar.png?v=1654850621748" alt="">
            </a>
            <div class="site-title">
                <h1>
                    ZileWang7的Blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            面经笔记
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2022-06-10</time>
                            
                                <a href="https://DDC777.github.io/tag/Q85lVW1jZ/" class="post-tag i-tag
                            i-tag-warning">
                            #Note
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <h2 id="html">HTML</h2>
<h4 id="html-语义化">HTML 语义化</h4>
<p>使用语义化标签而不是div, span</p>
<p>作用:</p>
<p>​		1.使人更易理解</p>
<p>​		2.SEO 使机器(搜索引擎 爬虫)能够理解</p>
<h4 id="行级块级元素块状内联">行级块级元素（块状，内联）</h4>
<p>display:block/table</p>
<p>​		有div h1 h2 table ul ol p等<br>
display: inline/inline-block</p>
<p>​		有 span img input button等</p>
<h4 id="script-标签中-defer-和-async">script 标签中 defer 和 async</h4>
<p>普通的sript：阻止HTML解析，下载并加载完后才会继续解析HTML</p>
<p>defer：异步下载，同步加载（HTML加载完后才会加载）</p>
<p>async：异步下载和加载，可能会阻碍HTML解析</p>
<h2 id="css">CSS</h2>
<h4 id="盒模型宽度计算">盒模型宽度计算</h4>
<p>width+padding*2+boder*2</p>
<p>使宽度计算方式包括内边距和边框:box-sizing: border-box;</p>
<h4 id="margin">margin</h4>
<h5 id="重叠">重叠</h5>
<p>相邻元素的margin-top和margin-bottom会重叠</p>
<p>空白内容也会发生重叠</p>
<h5 id="负值">负值</h5>
<p>margin-top和margin-left负值，元素向上、向左移动<br>
margin-right和margin-bottom负值，右侧元素左移，下方元素上移，<strong>自身不受影响</strong></p>
<h4 id="bfc">BFC</h4>
<p>Block format context ,块级格式化上下文</p>
<p>一块独立渲染区域，内部元素的渲染不会影响边界以外的元素</p>
<p>形成BFC的常见条件<br>
float不是none<br>
position 是 absolute 或 fixed<br>
overflow不是visible<br>
display 是 flex inline-block等</p>
<h4 id="float">float</h4>
<h5 id="两栏布局">两栏布局</h5>
<p>（左侧固定 + 右侧自适应布局）</p>
<p>现在有以下 DOM 结构：</p>
<pre><code class="language-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ol>
<li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li>
</ol>
<pre><code class="language-css">.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ol>
<pre><code class="language-css">.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li>
</ol>
<pre><code class="language-css">.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code> 定位，宽度固定。右边元素的 <code>margin-left</code> 的值设为左边元素的宽度值。</li>
</ol>
<pre><code class="language-css">.outer {
  position: relative;
  height: 100px;
}
.left {
  position: absolute;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code> 定位， <code>left</code> 为宽度大小，其余方向定位为 <code>0</code> 。</li>
</ol>
<pre><code class="language-css">.outer {
  position: relative;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  position: absolute;
  left: 200px;
  top: 0;
  right: 0;
  bottom: 0;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<h5 id="三栏布局">三栏布局</h5>
<p><strong>圣杯</strong>:</p>
<pre><code class="language-html">&lt;header style=&quot;background-color: rgb(233, 233, 233);&quot;&gt;header&lt;/header&gt;
    &lt;container class=&quot;container&quot;&gt;
        &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;
        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
    &lt;/container&gt;
&lt;footer style=&quot;background-color: rgb(233, 233, 233);&quot;&gt;footer&lt;/footer&gt;
</code></pre>
<pre><code class="language-css">.container {
    display: block;
    padding-left: 200px;
    padding-right: 300px;
}

.center {
    float: left;
    background-color: bisque;
    width: 100%;
}

.left {
    position: relative;
    float: left;
    background-color: aqua;
    width: 200px;
    margin-left: -100%;
    right: 200px;
}

.right {
    float: left;
    background-color: aquamarine;
    width: 300px;
    margin-right: -300px;
}

footer {
    clear: both;
}
</code></pre>
<p><strong>双飞翼</strong>:</p>
<pre><code class="language-html">&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;main-wrap&quot;&gt;
        main
    &lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;left&quot;&gt;
    left
&lt;/div&gt;
&lt;div id=&quot;right&quot;&gt;
    right
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">#main {
    width: 100%;
    height: 200px;
    background-color: greenyellow;
    float: left;
}

#main-wrap {
    margin-left: 200px;
    margin-right: 250px;
}

#left {
    width: 200px;
    height: 200px;
    background-color: aqua;
    float: left;
    margin-left: -100%;
}

#right {
    width: 250px;
    height: 200px;
    background-color: lightgreen;
    float: left;
    margin-left: -250px;
}
</code></pre>
<p>clear fix:</p>
<pre><code>.clearfix:after {
	content: '' ;
	display:table;
	clear:both;
}
.clearfix {
	*zoom:1;/*兼容IE低版本*/
}
</code></pre>
<h4 id="flex">flex</h4>
<p>flex-direction 主轴方向</p>
<p>justify-content 主轴对齐方式</p>
<p>align-items 交叉轴对齐方式</p>
<p>flex-wrap 换行</p>
<p>align-self 子元素交叉轴对齐</p>
<p><strong>画个色子</strong></p>
<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.box {
    width: 200px;
    height: 200px;
    border: 2px solid #ccc;
    border-radius: 10px;
    padding: 20px;

    display: flex;
    justify-content: space-between;
}

.item {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: palevioletred;
}

.item:nth-child(2) {
    align-self: center;
}

.item:nth-child(3) {
    align-self: flex-end;
}
</code></pre>
<h4 id="position">position</h4>
<p><strong>absolute和relative分别依据什么定位？</strong></p>
<p>relative依据<strong>自身定位</strong></p>
<p>自身位移并<strong>作为</strong>子元素(如果有)的<strong>定位基准</strong></p>
<p>absolute依据最近一层的<strong>定位元素</strong>定位</p>
<p>定位元素<br>
<strong>absolute</strong> relative fixed<br>
body(找不到absolute时)</p>
<h4 id="居中对齐实现方式">居中对齐实现方式</h4>
<p>水平居中<br>
inline元素：text-align:center<br>
block元素：margin:auto<br>
absolute元素：left:50%+<strong>margin-left负值</strong>(必须知道子元素尺寸) -宽度/2</p>
<p>垂直居中<br>
inline元素：line-height的值等于height值<br>
absolute元素：top:50%+margin-top负值<br>
absolute元素：transform(-50%,-50%)</p>
<p>​	absolute元素：top,left,bottom,right=0+margin:auto</p>
<h4 id="line-height-继承方式">line-height 继承方式:</h4>
<p>具体数值，如30px,则继承该值<br>
比例，如2/1.5,则继承该比例<br>
<strong>百分比</strong>，如200%,则继承<strong>计算出来的值</strong></p>
<h4 id="响应式remvwvh">响应式(rem/vw/vh)</h4>
<p>px,绝对长度单位，最常用<br>
em,相对长度单位，相对于父元素，不常用</p>
<p>root em rem,相对长度单位，相对于根元素，常用于响应式布局</p>
<p>vh网页视口高度的1/100<br>
vw网页视口宽度的1/100<br>
vmax 取两者最大值；vmin取两者最小值</p>
<p><strong>响应式布局的常用方案</strong></p>
<p>media-query,根据不同的屏幕宽度设置根元素 font-size<br>
rem,基于根元素的相对单位</p>
<p><strong>网页视口尺寸</strong></p>
<p>window.screen.height//屏幕高度<br>
window.innerHeight//网页视口高度<br>
document.body.clientHeight//body高度</p>
<h2 id="js">JS</h2>
<h3 id="变量类型和计算">变量类型和计算</h3>
<p><strong>值类型和引用类型的区别</strong></p>
<p>引用类型vs值类型</p>
<p>引用：储存内存地址（对象，数组，函数等）</p>
<p><strong>typeof 能判断哪些类型</strong></p>
<p>识别所有值类型<br>
识别函数<br>
判断是否是引用类型(object)（不可再细分）</p>
<p><strong>变量计算-类型转换</strong></p>
<p>字符串拼接: 拼接时有字符串则会转换为字符串 如  a = true + 'wdnmd'    //'truewdnmd'</p>
<p><strong>何时使用===何时使用==</strong></p>
<p>除==null，用===<br>
==:  '' == false -&gt; true; 0 == false -&gt; true; null == undifined -&gt; true</p>
<p>if 语句和逻辑运算 : !!(0/NaN/''/null/undefined/false) 为falsely变量，其他为truly</p>
<p><strong>深拷贝</strong></p>
<p>handle\1-深拷贝.ts</p>
<h3 id="原型原型链">原型原型链</h3>
<p>class 和继承</p>
<p>类型判断 instanceof</p>
<p>原型和原型链</p>
<p><strong>如何准确判断一个变量是不是数组？</strong></p>
<p>val instanceof Array // true/false</p>
<p>手写一个简易的jQuery,考虑插件和扩展性</p>
<p>class jQuery {}<br>
jQuery.prototype.chajian = function(args){}<br>
class jjQuery extends jQuery {}</p>
<p><strong>class 的原型本质，怎么理解？</strong></p>
<p>每个class都有显示原型prototype<br>
每个实例都有隐式原型__proto__<br>
实例的__proto__指向对应class的prototype</p>
<h3 id="作用域和闭包">作用域和闭包</h3>
<p><strong>作用域和自由变量</strong></p>
<p>全局作用域<br>
函数作用域<br>
块级作用域（ES6新增）</p>
<p>一个变量在当前作用域没有定义，但被使用了<br>
向上级作用域，一层一层依次寻找，直至找到为止<br>
如果到全局作用域都没找到，则报错xx is not defined</p>
<p><strong>闭包</strong></p>
<p>函数中自由变量的查找在函数定义的地方而不是执行的地方<br>
在函数定义的时候，如果当前作用域有被引用的变量，则会形成闭包</p>
<p><strong>this</strong></p>
<p>取值是在函数执行时确定的，而不是定义时确定的<br>
作为对象方法执行作用域为上级对象<br>
setTimeout的this指向window<br>
箭头函数this的取值始终为上级作用域</p>
<p><strong>this 的不同应用场景，如何取值？</strong></p>
<p>当做普通函数被调用: 执行时作用域<br>
使用call apply bind: 指定作用域<br>
作为对象方法调用: 上级对象<br>
在class的方法中调用: 对象本身<br>
箭头函数: 上级作用域</p>
<p>手写 bind 函数</p>
<p>handle\2-bind.ts</p>
<p>实际开发中闭包的应用场景，举例说明</p>
<p>隐藏数据,只提供api</p>
<h3 id="异步">异步</h3>
<p><strong>单线程和异步</strong></p>
<p>JS是单线程语言，只能同时做一件事儿<br>
浏览器和 nodejs 已支持JS启动进程，如Web Worker<br>
JS和DOM渲染共用同一个线程，因为JS可修改DOM结构</p>
<p>应用场景</p>
<p>网络请求，如ajax图片加载<br>
定时任务，如 setTimeout</p>
<p>callback hell 和 Promise</p>
<p>同步和异步的区别是什么？</p>
<p>基于JS是单线程语言<br>
异步不会阻塞代码执行<br>
同步会阻塞代码执行</p>
<p>手写用 Promise 加载一张图片</p>
<p>promise.ts</p>
<p>前端使用异步的场景有哪些？</p>
<p>网络请求，如ajax图片加载<br>
定时任务，如setTimeout</p>
<h4 id="event-loop-事件循环">event loop 事件循环</h4>
<p>JS如何执行？</p>
<p>从前到后，一行一行执行<br>
如果某一行执行报错，则停止下面代码的执行<br>
先把同步代码执行完，再执行异步</p>
<p><strong>event loop</strong></p>
<p>同步代码，一行一行放在Call Stack执行<br>
遇到异步，会先“记录”下，等待时机（定时、网络请求等）<br>
时机到了，就移动到 Callback Queue<br>
如 Call Stack为空（即同步代码执行完）Event Loop开始工<br>
轮询查找 Callback Queue,如有则移动到 Call Stack 执行<br>
然后继续轮询查找（永动机一样）</p>
<p><strong>DOM 事件和 event loop</strong></p>
<p>JS是单线程的<br>
异步（setTimeout,ajax等）使用回调，基于event loop<br>
DOM 事件也使用回调，基于 event loop</p>
<h4 id="promise">Promise</h4>
<p><strong>三种状态</strong></p>
<p>pending resolved rejected<br>
pending -&gt; resolved 或 pending -&gt; rejected<br>
变化不可逆</p>
<p><strong>状态的表现和变化</strong></p>
<p>pending状态，不会触发then和catch<br>
resolved 状态，会触发后续的 then 回调函数<br>
rejected状态，会触发后续的catch回调函数</p>
<p><strong>then 和 catch 对状态的影响</strong></p>
<p>then 正常返回 resolved,里面有报错则返回 rejected<br>
catch 正常返回 resolved,里面有报错则返回 rejected</p>
<h4 id="asyncawait">async/await</h4>
<p>异步回调 callback hell<br>
Promise then catch 链式调用，但也是基于回调函数<br>
async/await是同步语法，彻底消灭回调函数</p>
<p><strong>async/await和Promise的关系</strong></p>
<p>执行<strong>async</strong>函数，<strong>返回</strong>的是<strong>Promise对象</strong> (值封装为Promise对象，Promise直接返回)<br>
await 相当于 Promise 的 then<br>
try...catch 可捕获异常，代替了 Promise 的 catch</p>
<p><strong>for ... of</strong></p>
<p>for...in(以及forEach for)是常规的同步遍历<br>
for...of 常用于异步的遍历</p>
<h4 id="宏任务-macrotask和微任务-microtask">宏任务 macroTask和微任务 microTask</h4>
<p><strong>什么是宏任务，什么是微任务</strong></p>
<p>宏任务：setTimeout,setInterval,Ajax,DOM事件<br>
微任务：Promise async/await<br>
微任务执行时机比宏任务要早</p>
<p><strong>event loop 和 DOM 渲染</strong><br>
每次Call Stack清空（即每次轮询结束）,即同步任务执行完<br>
都是DOM重新渲染的机会，DOM结构如有改变则重新渲染<br>
然后再去触发下一次 Event Loop</p>
<p><strong>微任务和宏任务的区别</strong></p>
<p>宏任务：DOM渲染后触发，如setTimeout<br>
微任务：DOM渲染前触发，如Promise</p>
<p>微任务是ES6语法规定的<br>
宏任务是由浏览器规定的</p>
<p>宏任务有哪些？微任务有哪些？微任务触发时机更早<br>
微任务、宏任务和DOM渲染的关系<br>
微任务、宏任务和DOM渲染，在eventloop的过程</p>
<h4 id="手写promise">手写promise</h4>
<p>3-promise.ts</p>
<h2 id="js-web-api">JS Web API</h2>
<h2 id="dom">DOM</h2>
<p>DOM 本质</p>
<p>从HTML解析出来的一棵树</p>
<p><strong>DOM 节点操作</strong></p>
<p>获取DOM节点</p>
<pre><code class="language-javascript">const div1 = document.getElementById('div1')//元素
const divList = document.getElementsByTagName('div')//集合
const containerList = document.getElementsByClassName('.container')//集合
const pList = document.querySelectorAll('p')//集合

const p = pList[0]
</code></pre>
<p><strong>property</strong>:修改对象属性，不会体现到html结构中</p>
<pre><code class="language-javascript">console.log(p.style.width)//获取样式
p.style.width='100px'//修改样式

console.log(p.className)//获取class
p.className='p1'//修改 class

//获取 nodeName 和 nodeType
console.log(p.nodeName)
console.log(p.nodeType)
</code></pre>
<p><strong>attribute</strong>:修改html属性，会改变html结构</p>
<pre><code class="language-javascript">p.setAttribute('data-name','imooc')
o.setAttribute('style','font-size:30px;')
p.getAttribute('data-name')//imooc
p.getAttribute('style')//font-size:30px;
</code></pre>
<p>两者都有可能引起DOM重新渲染</p>
<p><strong>DOM 结构操作</strong></p>
<p>新增/插入节点</p>
<pre><code class="language-javascript">//新建节点
const newP = document.createElement('p')
newP.innerHTML='this is newp'
//插入节点
div1.appendChild(newP)

//移动节点(已在DOM中的节点appendChild不会复制)
const oldp = document.getElementById('oldp')
div2.appendChild(oldp)
</code></pre>
<p>获取父元素，子元素列表</p>
<pre><code class="language-javascript">//获取父元素
const divl = document.getElementById('div1')
const parent = divl. parentNode
//获取子元素列表
const divl = document.getElementById('divl')
const child = div1.childNodes
const child=Array.prototype.slice.call(div1.childNodes).filter(child =&gt; {
    if(child.nodeType === 1) return true;
    return false;
})
</code></pre>
<p>删除子元素</p>
<pre><code class="language-javascript">div1.removeChild(child[0])
</code></pre>
<p><strong>DOM 性能</strong></p>
<p>DOM操作非常“昂贵”，避免频繁的DOM操作<br>
对DOM查询做<strong>缓存</strong><br>
将<strong>频繁</strong>操作改为<strong>一次性</strong>操作</p>
<h2 id="bom">BOM</h2>
<p>navigator</p>
<p>如何识别浏览器的类型<br>
navigator.userAgent</p>
<p>screen</p>
<p>screen.width<br>
screen.height</p>
<p>location</p>
<p>网址：location.href<br>
协议：location.protocol<br>
域名：location.host<br>
协议+ 域名：location.origin<br>
路径：location.pathname<br>
参数：location.search<br>
锚点：location.hash</p>
<p>history</p>
<p>后退：history.back<br>
前进：history.forward</p>
<h2 id="事件">事件</h2>
<p><strong>事件绑定</strong></p>
<pre><code class="language-javascript">const btn = doucument.getElementById('btn');
btn.setEventListener('click',e =&gt; {alert('click')})

// console.log(e.target)//获取触发的元素
// event.preventDefault()//阻止默认行为
</code></pre>
<p><strong>事件冒泡</strong></p>
<p>事件会传递给父元素</p>
<pre><code class="language-javascript">// e.stopPropagation() //阻止冒泡
</code></pre>
<p><strong>事件代理</strong></p>
<p>代码简洁<br>
减少浏览器内存占用<br>
但是，不要滥用</p>
<pre><code class="language-javascript">div.addEventListener('click', e =&gt; {
    event.preventDefault();
    const target = event.target
    if(target.nodeName === 'A'){
        alert(target.innerHTML)
    }
})
</code></pre>
<p>编写一个通用的<strong>事件监听函数</strong></p>
<pre><code class="language-javascript">// function bindEvent(ele, type, fn){
//     ele.addEventListener(type,fn)
// }

function bindEvent(ele, type, selector, fn){
    if(!fn){
        fn = selector
        selector = null
    }
    ele.addEventListener(type,e =&gt; {
		const target = e.target
        if(selector){
            if(target.matches(selector)){
                fn.call(target, e)
            }
        } else {
            fn.call(target, e)
        }
    })
}

//普通绑定
bindEvent(btn, 'click', function(e) {
    e.preventDefault();
    alert(this.innerHTML)
})
//代理绑定
bindEvent(div, 'click', 'a', function(e) {
    e.preventDefault();
    alert(this.innerHTML)
})
</code></pre>
<p>描述事件冒泡的流程</p>
<p>基于DOM树形结构<br>
事件会顺着触发元素往上冒泡<br>
应用场景：代理</p>
<p>无限下拉的图片列表，如何监听每个图片的点击？</p>
<p>事件代理<br>
用 e.target获取触发元素<br>
用matches来判断是否是触发元素</p>
<h2 id="ajax">ajax</h2>
<p>XMLHttpRequest</p>
<p>xhr.readyState<br>
0-UNSET尚未调用open方法<br>
1-OPENED open方法已被调用<br>
2-HEADERS_RECEIVED send方法已被调用，header已被接收<br>
3-LOADING 下载中，responseText已有部分内容<br>
4-DONE 下载完成</p>
<p>状态码</p>
<p>xhr.status<br>
·2xx - 表示成功处理请求，如200<br>
·3xx - 需要重定向，浏览器直接跳转，如301 302 304<br>
·4xx - 客户端请求错误，如404 403<br>
·5xx - 服务器端错误</p>
<p>手写一个简易的 ajax</p>
<pre><code class="language-javascript">function ajax(url: string) {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(xhr.responseText)
                } else if (xhr.status === 404) {
                    reject(new Error('404NotFound'))
                }
            }
        }
        xhr.send(null)
    })

}
</code></pre>
<p>跨域：同源策略，跨域解决方案</p>
<p>什么是跨域（同源策略）</p>
<p>ajax请求时，浏览器要求当前网页和server必须同源（安全）<br>
同源：<strong>协议、域名、端口，三者必须一致</strong><br>
前端：http://a.com:8080/  server:https://b.com/api/xxx</p>
<p>**&lt;img/&gt;**可用于统计打点，可使用第三方统计服务<br>
**&lt;link/&gt;&lt;script&gt;**可使用CDN,CDN一般都是外域<br>
**&lt;script&gt;**可实现JSONP</p>
<p>所有的跨域，都必须经过 server 端允许和配合<br>
未经server端允许就实现跨域，说明浏览器有漏洞，危险信号</p>
<p><strong>JSONP</strong></p>
<p>服务器可以返回任何内容<br>
<strong>&lt;script&gt;可绕过跨域限制</strong><br>
<strong>服务器</strong>可以任意<strong>动态拼接数据返回</strong><br>
所以，&lt;script&gt;就可以获得跨域的数据，只要服务端愿意返回</p>
<p><strong>CORS</strong>(服务端支持)</p>
<h2 id="存储">存储</h2>
<p><strong>cookie</strong></p>
<p>本身用于浏览器和 server 通讯<br>
被“借用”到本地存储来<br>
可用 document.cookie = ... 来修改</p>
<p>cookie 的<strong>缺点</strong></p>
<p>存储大小，最大<strong>4KB</strong><br>
http请求时<strong>需要发送到服务端</strong>，增加请求数据量<br>
只能用 document.cookie = …来修改，太过简陋</p>
<p><strong>localStorage 和 sessionStorage</strong></p>
<p>HTML5专门为存储而设计，最大可存<strong>5M</strong><br>
API简单易用 <strong>setItem getItem</strong><br>
不会随着http请求被发送出去</p>
<p>localStorage 数据会<strong>永久存储</strong>，除非代码或手动删除<br>
sessionStorage 数据只存在于<strong>当前会话</strong>，浏览器关闭则清空<br>
一般用localStorage会更多一些</p>
<p>描述cookie localStorage sessionStorage 区别</p>
<p>容量<br>
API易用性<br>
是否跟随http请求发送出去</p>
<h2 id="http">HTTP</h2>
<p>前端工程师开发界面<br>
需要调用后端的接口，提交/获取数据——http协议<br>
要求事先掌握好ajax</p>
<h3 id="http-状态码">http 状态码</h3>
<p><strong>状态码分类</strong></p>
<p>1xx服务器收到请求<br>
2xx请求成功，如200<br>
3xx重定向，如302<br>
4xx客户端错误，如404<br>
5xx服务端错误，如500</p>
<p><strong>常见状态码</strong></p>
<p>200成功<br>
301永久重定向（配合location,浏览器自动处理<br>
302临时重定向（配合location,浏览器自动处理）<br>
304资源未被修改<br>
404资源未找到<br>
403没有权限<br>
500服务器错误<br>
504网关超时</p>
<p>关于协议和规范</p>
<p>就是一个约定<br>
要求大家都跟着执行<br>
不要违反规范，例如IE浏览器</p>
<h3 id="http-methods">http methods</h3>
<p>传统的methods</p>
<p>get获取服务器的数据<br>
post像服务器提交数据<br>
简单的网页功能，就这两个操作</p>
<p>现在的methods</p>
<p>get 获取数据<br>
post 新建数据<br>
patch/put更新数据<br>
delete删除数据</p>
<p><strong>Restful API</strong></p>
<p>一种新的API设计方法（早已推广使用）<br>
传统API设计：把每个url当做一个<strong>功能</strong><br>
Restful API设计：把每个url当做一个<strong>唯一的资源</strong></p>
<p>如何设计成一个资源？</p>
<p>不用url参数</p>
<p>传统API设计：/api/list?pageIndex=2<br>
Restful API设计：/api/list/2</p>
<p>用<strong>method</strong>表示<strong>操作类型</strong></p>
<p>传统API设计</p>
<p>post请求/api/create-blog<br>
post请求/api/update-blog?id=100<br>
get请求/api/get-blog?id=100</p>
<p>Restful API设计</p>
<p>post请求/api/blog<br>
patch 请求 /api/blog/100<br>
get 请求 /api/blog/100</p>
<p><strong>http headers</strong><br>
常见的 <strong>Request</strong> Headers</p>
<p>Accept 浏览器可接收的数据格式<br>
Accept-Encoding浏览器可接收的压缩算法，如gzip<br>
Accept-Languange 浏览器可接收的语言，如 zh-CN<br>
Connection:keep-alive一次TCP连接重复使用<br>
cookie<br>
Host<br>
User-Agent(简称UA)浏览器信息<br>
Content-type 发送数据的格式，如 application/json</p>
<p>常见的 <strong>Response</strong> Headers</p>
<p>Content-type 返回数据的格式，如 application/json<br>
Content-length 返回数据的大小，多少字节<br>
Content-Encoding 返回数据的压缩算法，如 gzip<br>
Set-Cookie</p>
<p><strong>缓存</strong>相关的headers</p>
<p>Cache-Control Expires<br>
Last-Modified If-Modified-Since<br>
If-None-Match<br>
Etag</p>
<h3 id="http缓存">http缓存</h3>
<p>什么是缓存？<br>
为什么需要缓存？<br>
哪些资源可以被缓存？一静态资源（js css img)</p>
<h4 id="强缓存与协商缓存">强缓存与协商缓存</h4>
<p><strong>强缓存</strong>：</p>
<p>​		如果没有过期，浏览器可以直接使用该缓存而不需要重新向服务器请求</p>
<p>​		Expires 存在于响应头，为缓存过期时间点</p>
<p>​		Cache-Control 存在于响应头和请求头，为缓存过期时常</p>
<p><strong>Cache-Control</strong></p>
<p>Response Headers 中<br>
控制强制缓存的逻辑<br>
例如 Cache-Control:max-age=31536000(单位是秒）</p>
<p><strong>max-age</strong> 过期时长<br>
<strong>no-cache</strong> 不用强制缓存<br>
no-store 不用任何缓存</p>
<p>private 只允许最终用户缓存<br>
public 允许路由/代理缓存</p>
<p>Expires</p>
<p>同在 Response Headers 中<br>
同为控制缓存过期<br>
已被 Cache-Control 代替</p>
<p><strong>协商缓存</strong>：</p>
<p>​		不能直接使用该缓存，始终向服务器询问是否需要更新</p>
<p>服务器端缓存策略<br>
服务器判断客户端资源，是否和服务端资源一样<br>
一致则返回304,否则返回200和最新的资源</p>
<p>在Response Headers中，有两种</p>
<p><strong>Last-Modified</strong> 资源的最后修改时间<br>
<strong>Etag</strong> 资源的唯一标识（一个字符串，类似人类的指纹）</p>
<h3 id="版本">版本</h3>
<p>HTTP/0.9</p>
<ul>
<li>只有一个命令GET</li>
<li>响应类型: 仅超文本</li>
<li>没有header等描述数据的信息</li>
<li>服务器发送完毕，就关闭TCP连接</li>
</ul>
<p>HTTP/1.0</p>
<ul>
<li>增加了很多命令（post HESD ）</li>
<li>增加<code>status code</code> 和 <code>header</code></li>
<li>多字符集支持、多部分发送、权限、缓存等</li>
<li>响应：不再只限于超文本 (Content-Type 头部提供了传输 HTML 之外文件的能力 — 如脚本、样式或媒体文件)</li>
</ul>
<p>HTTP/1.1</p>
<ul>
<li>持久连接。TCP三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）</li>
<li>支持的方法: <code>GET</code> , <code>HEAD</code> , <code>POST</code> , <code>PUT</code> ,<code>DELETE</code> , <code>TRACE</code> , <code>OPTIONS</code></li>
<li>进行了重大的性能优化和特性增强，分块传输、压缩/解压、内容缓存磋商、虚拟主机（有单个IP地址的主机具有多个域名）、更快的响应，以及通过增加缓存节省了更多的带宽</li>
</ul>
<p>HTTP2</p>
<ul>
<li>所有数据以二进制传输。HTTP1.x是基于文本的，无法保证健壮性，HTTP2.0绝对使用新的二进制格式，方便且健壮</li>
<li>同一个连接里面发送多个请求不再需要按照顺序来</li>
<li>头信息压缩以及推送等提高效率的功能</li>
</ul>
<p>HTTP3</p>
<ul>
<li>QUIC“快速UDP互联网连接”（Quick UDP Internet Connections）</li>
</ul>
<p>HTTP3 的主要改进在传输层上。传输层不会再有我前面提到的那些繁重的 TCP 连接了。现在，一切都会走 UDP。</p>
<h3 id="hsts">HSTS</h3>
<p>HTTP Strict Transport Security，简单说就是强制客户端使用 HTTPS 访问页面</p>
<p>原理：</p>
<ul>
<li>在服务器响应头中添加 <code>Strict-Transport-Security</code>，可以设置 <code>max-age</code></li>
<li>用户访问时，服务器种下这个头</li>
<li>下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码</li>
<li>变成 https 访问源服务器</li>
</ul>
<h3 id="http协议特点">HTTP协议特点</h3>
<ol>
<li>支持客户/服务器模式。</li>
<li>简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h3 id="tcp">TCP</h3>
<p>TCP(Transmission Control Protocol)传输控制协议</p>
<p>TCP/IP协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层</p>
<h4 id="连接三次握手">连接三次握手</h4>
<p>第一次握手：主机A发送位码为<code>SYN＝1</code>，随机产生<code>Seq number=1234567</code>的数据包到服务器，主机B由<code>SYN=1</code>知道，A要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</p>
<p>第二次握手：主机B收到请求后要确认联机信息，向A发送<code>ack number=(主机A的seq+1)</code>，<code>SUN=1，ACK=1234567 + 1</code>，随机产生<code>Seq=7654321</code>的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</p>
<p>第三次握手：主机A收到后检查<code>ack number</code>是否正确，即第一次发送的<code>seq number+1</code>，以及位码<code>SYN</code>是否为1，若正确，主机A会再发送<code>ack number=(主机B的seq+1)</code>，<code>ack=7654321 + 1</code>，主机B收到后确认<code>Seq</code>值与<code>ACK=7654321+ 1</code>则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</p>
<h4 id="断开四次分手">断开四次分手</h4>
<p>刚开始双方都处于established状态，假如是客户端先发起关闭请求</p>
<p>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态</p>
<p>第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态</p>
<p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态</p>
<p>需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p>
<h2 id="开发环境">开发环境</h2>
<p>git</p>
<p>常用git命令</p>
<p>git add .    添加<br>
git checkout xxx     还原<br>
git commit - m &quot; xxx &quot;    提交<br>
git push origin master    推送<br>
git pull origin master    拉去<br>
git branch    分支<br>
git checkout -b xxx  新建分支 / git checkout XXX    切换分支<br>
git merge xxx    合并分支<br>
git stash   暂存   git stash pop   恢复暂存</p>
<p>抓包</p>
<p>移动端h5页，查看网络请求，需要用工具抓包<br>
windows 一般用 fiddler<br>
Mac OS 一般用 charles</p>
<p>webpack babel</p>
<p>ES6模块化，浏览器暂不支持<br>
ES6语法，浏览器并不完全支持<br>
压缩代码，整合代码，以让网页加载更快</p>
<h2 id="运行环境">运行环境</h2>
<p>运行环境即浏览器（server端有nodejs)<br>
下载网页代码，渲染出页面，期间会执行若干JS<br>
要保证代码在浏览器中：稳定且高效</p>
<h3 id="网页加载过程">网页加载过程</h3>
<p>加载资源的<strong>形式</strong></p>
<p>html代码<br>
媒体文件，如图片、视频等<br>
javascript css</p>
<p><strong>加载过程</strong></p>
<p>DNS解析：域名-&gt;IP地址<br>
浏览器根据IP地址向服务器发起http请求<br>
服务器处理http请求，并返回给浏览器</p>
<p><strong>渲染</strong>过程</p>
<p>根据HTML代码生成DOM Tree<br>
根据CSS代码生成CSSOM<br>
将DOM Tree和CSSOM整合行程Render Tree<br>
根据Render Tree 渲染页面<br>
遇到&lt;script&gt;则暂停渲染，优先加载并执行JS代码，完成再继续<br>
直至把 Render Tree 渲染完成</p>
<h4 id="页面渲染">页面渲染</h4>
<p>HTML生成<strong>DOM</strong>树，CSS生成<strong>对象模型</strong>(<strong>CSSDOM</strong>)</p>
<p>DOM树与CSSDOM合并生成<strong>渲染树</strong></p>
<p>浏览器根据渲染树计算后生成<strong>布局树</strong>Layout Tree</p>
<p>最后将画面绘制到屏幕上</p>
<p><strong>window.onload 和 DOMContentLoaded 区别</strong></p>
<p>window.onload资源全部加载完才能执行，包括图片<br>
DOMContentLoaded DOM 渲染完成即可，图片可能尚未下载</p>
<h4 id="性能优化">性能优化</h4>
<p>是一个综合性问题，没有标准答案，但要求尽量全面<br>
某些细节问题可能会单独提问：手写防抖、节流</p>
<p><strong>性能优化原则</strong></p>
<p>多使用内存、缓存或其他方法<br>
减少CPU计算量，减少网络加载耗时<br>
(适用于所有编程的性能优化——空间换时间）</p>
<p><strong>让加载更快</strong><br>
减少资源体积：压缩代码<br>
减少访问次数：合并代码，SSR服务器端渲染，缓存<br>
使用更快的网络：CDN</p>
<p><strong>缓存</strong><br>
静态资源加 hash 后缀，根据文件内容计算 hash<br>
文件内容不变，则hash不变，则url不变<br>
url和文件不变，则会自动触发http缓存机制，返回304</p>
<p><strong>SSR</strong><br>
服务器端渲染：将网页和数据一起加载，一起渲染<br>
非SSR(前后端分离）:先加载网页，再加载数据，再渲染数据<br>
早先的JSP ASP PHP,现在的vue React SSR</p>
<p><strong>让渲染更快</strong><br>
CSS 放在 head ,JS 放在 body 最下面<br>
尽早开始执行JS,用DOMContentLoaded触发<br>
懒加载（图片懒加载，上滑加载更多）<br>
对DOM查询进行缓存<br>
频繁DOM操作，合并到一起插入DOM结构<br>
<strong>节流 throttle</strong> <strong>防抖 debounce</strong></p>
<pre><code class="language-javascript">const p = document.getElementsByTagName('p');
</code></pre>
<p><strong>防抖 debounce</strong></p>
<p>监听一个输入框的，文字变化后触发change事件<br>
直接用keyup事件，则会频发触发change事件<br>
防抖：用户输入结束或暂停时，才会触发change事件</p>
<pre><code class="language-javascript">const debounce = (fn: Function, delay: number = 500): EventListener =&gt; {
    let timer: NodeJS.Timeout;
    return function () {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            //@ts-ignore
            fn.apply(this, arguments);
        }, delay)
    }
}

p[0].addEventListener('click', debounce(function () {
    console.log(p[0]);
}, 600))
</code></pre>
<p><strong>节流 throttle</strong></p>
<p>拖拽一个元素时，要随时拿到该元素被拖拽的位置<br>
直接用drag事件，则会频发触发，很容易导致卡顿<br>
节流：无论拖拽速度多快，都会每隔100ms触发一次</p>
<pre><code class="language-javascript">const throttle = (fn: Function, delay: number = 100): EventListener =&gt; {
    let timer: NodeJS.Timeout | null = null;
    return function () {
        if (timer) return;
        timer = setTimeout(() =&gt; {
            //@ts-ignore
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}


p[0].addEventListener('drag', throttle(
    function (e: any) {
        console.log(e.offsetX, e.offsetY)
    }, 500)
);
</code></pre>
<h3 id="浏览器">浏览器</h3>
<h4 id="url">URL</h4>
<p>协议://主(ex.com)机:端口/路(a/b)径 ?查询(k=v&amp;k=v)参数#锚点</p>
<h4 id="dns">DNS</h4>
<p>从域名获取IP地址</p>
<p>根域名服务器，顶级域名服务器，主域名服务器</p>
<p>递归查询</p>
<p>​		客户端只发一次请求，要求对方给出最终结果。</p>
<p>​		浏览器缓存，系统缓存，路由器缓存，ISP(运营商)DNS缓存：统称为DNS高速缓存</p>
<p>​		若当前DNS服务器没有，则服务器会继续向其他DNS服务器查询</p>
<p>迭代查询</p>
<p>​		客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</p>
<p>​		当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
<h3 id="安全">安全</h3>
<p><strong>XSS跨站请求攻击</strong></p>
<p>一个博客网站，我发表一篇博客，其中嵌入&lt;script&gt;脚本<br>
脚本内容：获取cookie,发送到我的服务器（服务器配合跨域）<br>
发布这篇博客，有人查看它，窃取访问者的cookie</p>
<p><strong>XSS 预防</strong>(xss 工具)</p>
<p>替换特殊字符，如&lt;变为&lt;&gt;变为&gt;<br>
&lt;script&gt;变为 &amp;lt;script&amp;gt;,直接显示，而不会作为脚本执行<br>
前端要替换，后端也要替换，都做总不会有错</p>
<p><strong>XSRF跨站请求伪造</strong></p>
<p>你正在购物，看中了某个商品，商品id是100<br>
付费接口是xxx.com/pay?id=100,但没有任何验证<br>
我是攻击者，我看中了一个商品，id是200<br>
我向你发送一封电子邮件，邮件标题很吸引人<br>
但邮件正文隐藏着&lt;img src=xxx.com/pay?id=200/&gt;<br>
你一查看邮件，就帮我购买了id是200的商品</p>
<p><strong>XSRF 预防</strong></p>
<p>使用post接口<br>
增加验证，例如密码、短信验证码、指纹等</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://DDC777.github.io/post/javawindowbuildermysql-shi-xian-fan-dian-guan-li-xi-tong/">
                                <h3 class="post-title">
                                    JAVA+WindowBuilder+MySQL实现饭店管理系统
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#html">HTML</a><br>
*
<ul>
<li><a href="#html-%E8%AF%AD%E4%B9%89%E5%8C%96">HTML 语义化</a></li>
<li><a href="#%E8%A1%8C%E7%BA%A7%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%9D%97%E7%8A%B6%E5%86%85%E8%81%94">行级块级元素（块状，内联）</a></li>
<li><a href="#script-%E6%A0%87%E7%AD%BE%E4%B8%AD-defer-%E5%92%8C-async">script 标签中 defer 和 async</a></li>
</ul>
</li>
<li><a href="#css">CSS</a><br>
*
<ul>
<li><a href="#%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%AE%BD%E5%BA%A6%E8%AE%A1%E7%AE%97">盒模型宽度计算</a></li>
<li><a href="#margin">margin</a>
<ul>
<li><a href="#%E9%87%8D%E5%8F%A0">重叠</a></li>
<li><a href="#%E8%B4%9F%E5%80%BC">负值</a></li>
</ul>
</li>
<li><a href="#bfc">BFC</a></li>
<li><a href="#float">float</a>
<ul>
<li><a href="#%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80">两栏布局</a></li>
<li><a href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80">三栏布局</a></li>
</ul>
</li>
<li><a href="#flex">flex</a></li>
<li><a href="#position">position</a></li>
<li><a href="#%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">居中对齐实现方式</a></li>
<li><a href="#line-height-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">line-height 继承方式:</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8Fremvwvh">响应式(rem/vw/vh)</a></li>
</ul>
</li>
<li><a href="#js">JS</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97">变量类型和计算</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE">原型原型链</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85">作用域和闭包</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5">异步</a>
<ul>
<li><a href="#event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">event loop 事件循环</a></li>
<li><a href="#promise">Promise</a></li>
<li><a href="#asyncawait">async/await</a></li>
<li><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1-macrotask%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-microtask">宏任务 macroTask和微任务 microTask</a></li>
<li><a href="#%E6%89%8B%E5%86%99promise">手写promise</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#js-web-api">JS Web API</a></li>
<li><a href="#dom">DOM</a></li>
<li><a href="#bom">BOM</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6">事件</a></li>
<li><a href="#ajax">ajax</a></li>
<li><a href="#%E5%AD%98%E5%82%A8">存储</a></li>
<li><a href="#http">HTTP</a>
<ul>
<li><a href="#http-%E7%8A%B6%E6%80%81%E7%A0%81">http 状态码</a></li>
<li><a href="#http-methods">http methods</a></li>
<li><a href="#http%E7%BC%93%E5%AD%98">http缓存</a>
<ul>
<li><a href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">强缓存与协商缓存</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="#hsts">HSTS</a></li>
<li><a href="#http%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9">HTTP协议特点</a></li>
<li><a href="#tcp">TCP</a>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">连接三次握手</a></li>
<li><a href="#%E6%96%AD%E5%BC%80%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B">断开四次分手</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">运行环境</a>
<ul>
<li><a href="#%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">网页加载过程</a>
<ul>
<li><a href="#%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93">页面渲染</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>
<ul>
<li><a href="#url">URL</a></li>
<li><a href="#dns">DNS</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8">安全</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
   | 
  <a class="rss" href="https://DDC777.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>