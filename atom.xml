<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://DDC777.github.io</id>
    <title>ZileWang7的Blog</title>
    <updated>2022-06-10T08:44:30.162Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://DDC777.github.io"/>
    <link rel="self" href="https://DDC777.github.io/atom.xml"/>
    <subtitle>等🐓啄完了🍚，🐕舔完了🍜，🔥烧断了🔒
Bolg就不🕊了</subtitle>
    <logo>https://DDC777.github.io/images/avatar.png</logo>
    <icon>https://DDC777.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, ZileWang7的Blog</rights>
    <entry>
        <title type="html"><![CDATA[面经笔记]]></title>
        <id>https://DDC777.github.io/post/mian-jing-bi-ji/</id>
        <link href="https://DDC777.github.io/post/mian-jing-bi-ji/">
        </link>
        <updated>2022-06-10T08:36:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html">HTML</h2>
<h4 id="html-语义化">HTML 语义化</h4>
<p>使用语义化标签而不是div, span</p>
<p>作用:</p>
<p>​		1.使人更易理解</p>
<p>​		2.SEO 使机器(搜索引擎 爬虫)能够理解</p>
<h4 id="行级块级元素块状内联">行级块级元素（块状，内联）</h4>
<p>display:block/table</p>
<p>​		有div h1 h2 table ul ol p等<br>
display: inline/inline-block</p>
<p>​		有 span img input button等</p>
<h4 id="script-标签中-defer-和-async">script 标签中 defer 和 async</h4>
<p>普通的sript：阻止HTML解析，下载并加载完后才会继续解析HTML</p>
<p>defer：异步下载，同步加载（HTML加载完后才会加载）</p>
<p>async：异步下载和加载，可能会阻碍HTML解析</p>
<h2 id="css">CSS</h2>
<h4 id="盒模型宽度计算">盒模型宽度计算</h4>
<p>width+padding*2+boder*2</p>
<p>使宽度计算方式包括内边距和边框:box-sizing: border-box;</p>
<h4 id="margin">margin</h4>
<h5 id="重叠">重叠</h5>
<p>相邻元素的margin-top和margin-bottom会重叠</p>
<p>空白内容也会发生重叠</p>
<h5 id="负值">负值</h5>
<p>margin-top和margin-left负值，元素向上、向左移动<br>
margin-right和margin-bottom负值，右侧元素左移，下方元素上移，<strong>自身不受影响</strong></p>
<h4 id="bfc">BFC</h4>
<p>Block format context ,块级格式化上下文</p>
<p>一块独立渲染区域，内部元素的渲染不会影响边界以外的元素</p>
<p>形成BFC的常见条件<br>
float不是none<br>
position 是 absolute 或 fixed<br>
overflow不是visible<br>
display 是 flex inline-block等</p>
<h4 id="float">float</h4>
<h5 id="两栏布局">两栏布局</h5>
<p>（左侧固定 + 右侧自适应布局）</p>
<p>现在有以下 DOM 结构：</p>
<pre><code class="language-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ol>
<li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li>
</ol>
<pre><code class="language-css">.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ol>
<pre><code class="language-css">.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li>
</ol>
<pre><code class="language-css">.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code> 定位，宽度固定。右边元素的 <code>margin-left</code> 的值设为左边元素的宽度值。</li>
</ol>
<pre><code class="language-css">.outer {
  position: relative;
  height: 100px;
}
.left {
  position: absolute;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code> 定位， <code>left</code> 为宽度大小，其余方向定位为 <code>0</code> 。</li>
</ol>
<pre><code class="language-css">.outer {
  position: relative;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  position: absolute;
  left: 200px;
  top: 0;
  right: 0;
  bottom: 0;
  height: 100%;
  background: lightseagreen;
}
</code></pre>
<h5 id="三栏布局">三栏布局</h5>
<p><strong>圣杯</strong>:</p>
<pre><code class="language-html">&lt;header style=&quot;background-color: rgb(233, 233, 233);&quot;&gt;header&lt;/header&gt;
    &lt;container class=&quot;container&quot;&gt;
        &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;
        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
    &lt;/container&gt;
&lt;footer style=&quot;background-color: rgb(233, 233, 233);&quot;&gt;footer&lt;/footer&gt;
</code></pre>
<pre><code class="language-css">.container {
    display: block;
    padding-left: 200px;
    padding-right: 300px;
}

.center {
    float: left;
    background-color: bisque;
    width: 100%;
}

.left {
    position: relative;
    float: left;
    background-color: aqua;
    width: 200px;
    margin-left: -100%;
    right: 200px;
}

.right {
    float: left;
    background-color: aquamarine;
    width: 300px;
    margin-right: -300px;
}

footer {
    clear: both;
}
</code></pre>
<p><strong>双飞翼</strong>:</p>
<pre><code class="language-html">&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;main-wrap&quot;&gt;
        main
    &lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;left&quot;&gt;
    left
&lt;/div&gt;
&lt;div id=&quot;right&quot;&gt;
    right
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">#main {
    width: 100%;
    height: 200px;
    background-color: greenyellow;
    float: left;
}

#main-wrap {
    margin-left: 200px;
    margin-right: 250px;
}

#left {
    width: 200px;
    height: 200px;
    background-color: aqua;
    float: left;
    margin-left: -100%;
}

#right {
    width: 250px;
    height: 200px;
    background-color: lightgreen;
    float: left;
    margin-left: -250px;
}
</code></pre>
<p>clear fix:</p>
<pre><code>.clearfix:after {
	content: '' ;
	display:table;
	clear:both;
}
.clearfix {
	*zoom:1;/*兼容IE低版本*/
}
</code></pre>
<h4 id="flex">flex</h4>
<p>flex-direction 主轴方向</p>
<p>justify-content 主轴对齐方式</p>
<p>align-items 交叉轴对齐方式</p>
<p>flex-wrap 换行</p>
<p>align-self 子元素交叉轴对齐</p>
<p><strong>画个色子</strong></p>
<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.box {
    width: 200px;
    height: 200px;
    border: 2px solid #ccc;
    border-radius: 10px;
    padding: 20px;

    display: flex;
    justify-content: space-between;
}

.item {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: palevioletred;
}

.item:nth-child(2) {
    align-self: center;
}

.item:nth-child(3) {
    align-self: flex-end;
}
</code></pre>
<h4 id="position">position</h4>
<p><strong>absolute和relative分别依据什么定位？</strong></p>
<p>relative依据<strong>自身定位</strong></p>
<p>自身位移并<strong>作为</strong>子元素(如果有)的<strong>定位基准</strong></p>
<p>absolute依据最近一层的<strong>定位元素</strong>定位</p>
<p>定位元素<br>
<strong>absolute</strong> relative fixed<br>
body(找不到absolute时)</p>
<h4 id="居中对齐实现方式">居中对齐实现方式</h4>
<p>水平居中<br>
inline元素：text-align:center<br>
block元素：margin:auto<br>
absolute元素：left:50%+<strong>margin-left负值</strong>(必须知道子元素尺寸) -宽度/2</p>
<p>垂直居中<br>
inline元素：line-height的值等于height值<br>
absolute元素：top:50%+margin-top负值<br>
absolute元素：transform(-50%,-50%)</p>
<p>​	absolute元素：top,left,bottom,right=0+margin:auto</p>
<h4 id="line-height-继承方式">line-height 继承方式:</h4>
<p>具体数值，如30px,则继承该值<br>
比例，如2/1.5,则继承该比例<br>
<strong>百分比</strong>，如200%,则继承<strong>计算出来的值</strong></p>
<h4 id="响应式remvwvh">响应式(rem/vw/vh)</h4>
<p>px,绝对长度单位，最常用<br>
em,相对长度单位，相对于父元素，不常用</p>
<p>root em rem,相对长度单位，相对于根元素，常用于响应式布局</p>
<p>vh网页视口高度的1/100<br>
vw网页视口宽度的1/100<br>
vmax 取两者最大值；vmin取两者最小值</p>
<p><strong>响应式布局的常用方案</strong></p>
<p>media-query,根据不同的屏幕宽度设置根元素 font-size<br>
rem,基于根元素的相对单位</p>
<p><strong>网页视口尺寸</strong></p>
<p>window.screen.height//屏幕高度<br>
window.innerHeight//网页视口高度<br>
document.body.clientHeight//body高度</p>
<h2 id="js">JS</h2>
<h3 id="变量类型和计算">变量类型和计算</h3>
<p><strong>值类型和引用类型的区别</strong></p>
<p>引用类型vs值类型</p>
<p>引用：储存内存地址（对象，数组，函数等）</p>
<p><strong>typeof 能判断哪些类型</strong></p>
<p>识别所有值类型<br>
识别函数<br>
判断是否是引用类型(object)（不可再细分）</p>
<p><strong>变量计算-类型转换</strong></p>
<p>字符串拼接: 拼接时有字符串则会转换为字符串 如  a = true + 'wdnmd'    //'truewdnmd'</p>
<p><strong>何时使用===何时使用==</strong></p>
<p>除==null，用===<br>
==:  '' == false -&gt; true; 0 == false -&gt; true; null == undifined -&gt; true</p>
<p>if 语句和逻辑运算 : !!(0/NaN/''/null/undefined/false) 为falsely变量，其他为truly</p>
<p><strong>深拷贝</strong></p>
<p>handle\1-深拷贝.ts</p>
<h3 id="原型原型链">原型原型链</h3>
<p>class 和继承</p>
<p>类型判断 instanceof</p>
<p>原型和原型链</p>
<p><strong>如何准确判断一个变量是不是数组？</strong></p>
<p>val instanceof Array // true/false</p>
<p>手写一个简易的jQuery,考虑插件和扩展性</p>
<p>class jQuery {}<br>
jQuery.prototype.chajian = function(args){}<br>
class jjQuery extends jQuery {}</p>
<p><strong>class 的原型本质，怎么理解？</strong></p>
<p>每个class都有显示原型prototype<br>
每个实例都有隐式原型__proto__<br>
实例的__proto__指向对应class的prototype</p>
<h3 id="作用域和闭包">作用域和闭包</h3>
<p><strong>作用域和自由变量</strong></p>
<p>全局作用域<br>
函数作用域<br>
块级作用域（ES6新增）</p>
<p>一个变量在当前作用域没有定义，但被使用了<br>
向上级作用域，一层一层依次寻找，直至找到为止<br>
如果到全局作用域都没找到，则报错xx is not defined</p>
<p><strong>闭包</strong></p>
<p>函数中自由变量的查找在函数定义的地方而不是执行的地方<br>
在函数定义的时候，如果当前作用域有被引用的变量，则会形成闭包</p>
<p><strong>this</strong></p>
<p>取值是在函数执行时确定的，而不是定义时确定的<br>
作为对象方法执行作用域为上级对象<br>
setTimeout的this指向window<br>
箭头函数this的取值始终为上级作用域</p>
<p><strong>this 的不同应用场景，如何取值？</strong></p>
<p>当做普通函数被调用: 执行时作用域<br>
使用call apply bind: 指定作用域<br>
作为对象方法调用: 上级对象<br>
在class的方法中调用: 对象本身<br>
箭头函数: 上级作用域</p>
<p>手写 bind 函数</p>
<p>handle\2-bind.ts</p>
<p>实际开发中闭包的应用场景，举例说明</p>
<p>隐藏数据,只提供api</p>
<h3 id="异步">异步</h3>
<p><strong>单线程和异步</strong></p>
<p>JS是单线程语言，只能同时做一件事儿<br>
浏览器和 nodejs 已支持JS启动进程，如Web Worker<br>
JS和DOM渲染共用同一个线程，因为JS可修改DOM结构</p>
<p>应用场景</p>
<p>网络请求，如ajax图片加载<br>
定时任务，如 setTimeout</p>
<p>callback hell 和 Promise</p>
<p>同步和异步的区别是什么？</p>
<p>基于JS是单线程语言<br>
异步不会阻塞代码执行<br>
同步会阻塞代码执行</p>
<p>手写用 Promise 加载一张图片</p>
<p>promise.ts</p>
<p>前端使用异步的场景有哪些？</p>
<p>网络请求，如ajax图片加载<br>
定时任务，如setTimeout</p>
<h4 id="event-loop-事件循环">event loop 事件循环</h4>
<p>JS如何执行？</p>
<p>从前到后，一行一行执行<br>
如果某一行执行报错，则停止下面代码的执行<br>
先把同步代码执行完，再执行异步</p>
<p><strong>event loop</strong></p>
<p>同步代码，一行一行放在Call Stack执行<br>
遇到异步，会先“记录”下，等待时机（定时、网络请求等）<br>
时机到了，就移动到 Callback Queue<br>
如 Call Stack为空（即同步代码执行完）Event Loop开始工<br>
轮询查找 Callback Queue,如有则移动到 Call Stack 执行<br>
然后继续轮询查找（永动机一样）</p>
<p><strong>DOM 事件和 event loop</strong></p>
<p>JS是单线程的<br>
异步（setTimeout,ajax等）使用回调，基于event loop<br>
DOM 事件也使用回调，基于 event loop</p>
<h4 id="promise">Promise</h4>
<p><strong>三种状态</strong></p>
<p>pending resolved rejected<br>
pending -&gt; resolved 或 pending -&gt; rejected<br>
变化不可逆</p>
<p><strong>状态的表现和变化</strong></p>
<p>pending状态，不会触发then和catch<br>
resolved 状态，会触发后续的 then 回调函数<br>
rejected状态，会触发后续的catch回调函数</p>
<p><strong>then 和 catch 对状态的影响</strong></p>
<p>then 正常返回 resolved,里面有报错则返回 rejected<br>
catch 正常返回 resolved,里面有报错则返回 rejected</p>
<h4 id="asyncawait">async/await</h4>
<p>异步回调 callback hell<br>
Promise then catch 链式调用，但也是基于回调函数<br>
async/await是同步语法，彻底消灭回调函数</p>
<p><strong>async/await和Promise的关系</strong></p>
<p>执行<strong>async</strong>函数，<strong>返回</strong>的是<strong>Promise对象</strong> (值封装为Promise对象，Promise直接返回)<br>
await 相当于 Promise 的 then<br>
try...catch 可捕获异常，代替了 Promise 的 catch</p>
<p><strong>for ... of</strong></p>
<p>for...in(以及forEach for)是常规的同步遍历<br>
for...of 常用于异步的遍历</p>
<h4 id="宏任务-macrotask和微任务-microtask">宏任务 macroTask和微任务 microTask</h4>
<p><strong>什么是宏任务，什么是微任务</strong></p>
<p>宏任务：setTimeout,setInterval,Ajax,DOM事件<br>
微任务：Promise async/await<br>
微任务执行时机比宏任务要早</p>
<p><strong>event loop 和 DOM 渲染</strong><br>
每次Call Stack清空（即每次轮询结束）,即同步任务执行完<br>
都是DOM重新渲染的机会，DOM结构如有改变则重新渲染<br>
然后再去触发下一次 Event Loop</p>
<p><strong>微任务和宏任务的区别</strong></p>
<p>宏任务：DOM渲染后触发，如setTimeout<br>
微任务：DOM渲染前触发，如Promise</p>
<p>微任务是ES6语法规定的<br>
宏任务是由浏览器规定的</p>
<p>宏任务有哪些？微任务有哪些？微任务触发时机更早<br>
微任务、宏任务和DOM渲染的关系<br>
微任务、宏任务和DOM渲染，在eventloop的过程</p>
<h4 id="手写promise">手写promise</h4>
<p>3-promise.ts</p>
<h2 id="js-web-api">JS Web API</h2>
<h2 id="dom">DOM</h2>
<p>DOM 本质</p>
<p>从HTML解析出来的一棵树</p>
<p><strong>DOM 节点操作</strong></p>
<p>获取DOM节点</p>
<pre><code class="language-javascript">const div1 = document.getElementById('div1')//元素
const divList = document.getElementsByTagName('div')//集合
const containerList = document.getElementsByClassName('.container')//集合
const pList = document.querySelectorAll('p')//集合

const p = pList[0]
</code></pre>
<p><strong>property</strong>:修改对象属性，不会体现到html结构中</p>
<pre><code class="language-javascript">console.log(p.style.width)//获取样式
p.style.width='100px'//修改样式

console.log(p.className)//获取class
p.className='p1'//修改 class

//获取 nodeName 和 nodeType
console.log(p.nodeName)
console.log(p.nodeType)
</code></pre>
<p><strong>attribute</strong>:修改html属性，会改变html结构</p>
<pre><code class="language-javascript">p.setAttribute('data-name','imooc')
o.setAttribute('style','font-size:30px;')
p.getAttribute('data-name')//imooc
p.getAttribute('style')//font-size:30px;
</code></pre>
<p>两者都有可能引起DOM重新渲染</p>
<p><strong>DOM 结构操作</strong></p>
<p>新增/插入节点</p>
<pre><code class="language-javascript">//新建节点
const newP = document.createElement('p')
newP.innerHTML='this is newp'
//插入节点
div1.appendChild(newP)

//移动节点(已在DOM中的节点appendChild不会复制)
const oldp = document.getElementById('oldp')
div2.appendChild(oldp)
</code></pre>
<p>获取父元素，子元素列表</p>
<pre><code class="language-javascript">//获取父元素
const divl = document.getElementById('div1')
const parent = divl. parentNode
//获取子元素列表
const divl = document.getElementById('divl')
const child = div1.childNodes
const child=Array.prototype.slice.call(div1.childNodes).filter(child =&gt; {
    if(child.nodeType === 1) return true;
    return false;
})
</code></pre>
<p>删除子元素</p>
<pre><code class="language-javascript">div1.removeChild(child[0])
</code></pre>
<p><strong>DOM 性能</strong></p>
<p>DOM操作非常“昂贵”，避免频繁的DOM操作<br>
对DOM查询做<strong>缓存</strong><br>
将<strong>频繁</strong>操作改为<strong>一次性</strong>操作</p>
<h2 id="bom">BOM</h2>
<p>navigator</p>
<p>如何识别浏览器的类型<br>
navigator.userAgent</p>
<p>screen</p>
<p>screen.width<br>
screen.height</p>
<p>location</p>
<p>网址：location.href<br>
协议：location.protocol<br>
域名：location.host<br>
协议+ 域名：location.origin<br>
路径：location.pathname<br>
参数：location.search<br>
锚点：location.hash</p>
<p>history</p>
<p>后退：history.back<br>
前进：history.forward</p>
<h2 id="事件">事件</h2>
<p><strong>事件绑定</strong></p>
<pre><code class="language-javascript">const btn = doucument.getElementById('btn');
btn.setEventListener('click',e =&gt; {alert('click')})

// console.log(e.target)//获取触发的元素
// event.preventDefault()//阻止默认行为
</code></pre>
<p><strong>事件冒泡</strong></p>
<p>事件会传递给父元素</p>
<pre><code class="language-javascript">// e.stopPropagation() //阻止冒泡
</code></pre>
<p><strong>事件代理</strong></p>
<p>代码简洁<br>
减少浏览器内存占用<br>
但是，不要滥用</p>
<pre><code class="language-javascript">div.addEventListener('click', e =&gt; {
    event.preventDefault();
    const target = event.target
    if(target.nodeName === 'A'){
        alert(target.innerHTML)
    }
})
</code></pre>
<p>编写一个通用的<strong>事件监听函数</strong></p>
<pre><code class="language-javascript">// function bindEvent(ele, type, fn){
//     ele.addEventListener(type,fn)
// }

function bindEvent(ele, type, selector, fn){
    if(!fn){
        fn = selector
        selector = null
    }
    ele.addEventListener(type,e =&gt; {
		const target = e.target
        if(selector){
            if(target.matches(selector)){
                fn.call(target, e)
            }
        } else {
            fn.call(target, e)
        }
    })
}

//普通绑定
bindEvent(btn, 'click', function(e) {
    e.preventDefault();
    alert(this.innerHTML)
})
//代理绑定
bindEvent(div, 'click', 'a', function(e) {
    e.preventDefault();
    alert(this.innerHTML)
})
</code></pre>
<p>描述事件冒泡的流程</p>
<p>基于DOM树形结构<br>
事件会顺着触发元素往上冒泡<br>
应用场景：代理</p>
<p>无限下拉的图片列表，如何监听每个图片的点击？</p>
<p>事件代理<br>
用 e.target获取触发元素<br>
用matches来判断是否是触发元素</p>
<h2 id="ajax">ajax</h2>
<p>XMLHttpRequest</p>
<p>xhr.readyState<br>
0-UNSET尚未调用open方法<br>
1-OPENED open方法已被调用<br>
2-HEADERS_RECEIVED send方法已被调用，header已被接收<br>
3-LOADING 下载中，responseText已有部分内容<br>
4-DONE 下载完成</p>
<p>状态码</p>
<p>xhr.status<br>
·2xx - 表示成功处理请求，如200<br>
·3xx - 需要重定向，浏览器直接跳转，如301 302 304<br>
·4xx - 客户端请求错误，如404 403<br>
·5xx - 服务器端错误</p>
<p>手写一个简易的 ajax</p>
<pre><code class="language-javascript">function ajax(url: string) {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(xhr.responseText)
                } else if (xhr.status === 404) {
                    reject(new Error('404NotFound'))
                }
            }
        }
        xhr.send(null)
    })

}
</code></pre>
<p>跨域：同源策略，跨域解决方案</p>
<p>什么是跨域（同源策略）</p>
<p>ajax请求时，浏览器要求当前网页和server必须同源（安全）<br>
同源：<strong>协议、域名、端口，三者必须一致</strong><br>
前端：http://a.com:8080/  server:https://b.com/api/xxx</p>
<p>**&lt;img/&gt;**可用于统计打点，可使用第三方统计服务<br>
**&lt;link/&gt;&lt;script&gt;**可使用CDN,CDN一般都是外域<br>
**&lt;script&gt;**可实现JSONP</p>
<p>所有的跨域，都必须经过 server 端允许和配合<br>
未经server端允许就实现跨域，说明浏览器有漏洞，危险信号</p>
<p><strong>JSONP</strong></p>
<p>服务器可以返回任何内容<br>
<strong>&lt;script&gt;可绕过跨域限制</strong><br>
<strong>服务器</strong>可以任意<strong>动态拼接数据返回</strong><br>
所以，&lt;script&gt;就可以获得跨域的数据，只要服务端愿意返回</p>
<p><strong>CORS</strong>(服务端支持)</p>
<h2 id="存储">存储</h2>
<p><strong>cookie</strong></p>
<p>本身用于浏览器和 server 通讯<br>
被“借用”到本地存储来<br>
可用 document.cookie = ... 来修改</p>
<p>cookie 的<strong>缺点</strong></p>
<p>存储大小，最大<strong>4KB</strong><br>
http请求时<strong>需要发送到服务端</strong>，增加请求数据量<br>
只能用 document.cookie = …来修改，太过简陋</p>
<p><strong>localStorage 和 sessionStorage</strong></p>
<p>HTML5专门为存储而设计，最大可存<strong>5M</strong><br>
API简单易用 <strong>setItem getItem</strong><br>
不会随着http请求被发送出去</p>
<p>localStorage 数据会<strong>永久存储</strong>，除非代码或手动删除<br>
sessionStorage 数据只存在于<strong>当前会话</strong>，浏览器关闭则清空<br>
一般用localStorage会更多一些</p>
<p>描述cookie localStorage sessionStorage 区别</p>
<p>容量<br>
API易用性<br>
是否跟随http请求发送出去</p>
<h2 id="http">HTTP</h2>
<p>前端工程师开发界面<br>
需要调用后端的接口，提交/获取数据——http协议<br>
要求事先掌握好ajax</p>
<h3 id="http-状态码">http 状态码</h3>
<p><strong>状态码分类</strong></p>
<p>1xx服务器收到请求<br>
2xx请求成功，如200<br>
3xx重定向，如302<br>
4xx客户端错误，如404<br>
5xx服务端错误，如500</p>
<p><strong>常见状态码</strong></p>
<p>200成功<br>
301永久重定向（配合location,浏览器自动处理<br>
302临时重定向（配合location,浏览器自动处理）<br>
304资源未被修改<br>
404资源未找到<br>
403没有权限<br>
500服务器错误<br>
504网关超时</p>
<p>关于协议和规范</p>
<p>就是一个约定<br>
要求大家都跟着执行<br>
不要违反规范，例如IE浏览器</p>
<h3 id="http-methods">http methods</h3>
<p>传统的methods</p>
<p>get获取服务器的数据<br>
post像服务器提交数据<br>
简单的网页功能，就这两个操作</p>
<p>现在的methods</p>
<p>get 获取数据<br>
post 新建数据<br>
patch/put更新数据<br>
delete删除数据</p>
<p><strong>Restful API</strong></p>
<p>一种新的API设计方法（早已推广使用）<br>
传统API设计：把每个url当做一个<strong>功能</strong><br>
Restful API设计：把每个url当做一个<strong>唯一的资源</strong></p>
<p>如何设计成一个资源？</p>
<p>不用url参数</p>
<p>传统API设计：/api/list?pageIndex=2<br>
Restful API设计：/api/list/2</p>
<p>用<strong>method</strong>表示<strong>操作类型</strong></p>
<p>传统API设计</p>
<p>post请求/api/create-blog<br>
post请求/api/update-blog?id=100<br>
get请求/api/get-blog?id=100</p>
<p>Restful API设计</p>
<p>post请求/api/blog<br>
patch 请求 /api/blog/100<br>
get 请求 /api/blog/100</p>
<p><strong>http headers</strong><br>
常见的 <strong>Request</strong> Headers</p>
<p>Accept 浏览器可接收的数据格式<br>
Accept-Encoding浏览器可接收的压缩算法，如gzip<br>
Accept-Languange 浏览器可接收的语言，如 zh-CN<br>
Connection:keep-alive一次TCP连接重复使用<br>
cookie<br>
Host<br>
User-Agent(简称UA)浏览器信息<br>
Content-type 发送数据的格式，如 application/json</p>
<p>常见的 <strong>Response</strong> Headers</p>
<p>Content-type 返回数据的格式，如 application/json<br>
Content-length 返回数据的大小，多少字节<br>
Content-Encoding 返回数据的压缩算法，如 gzip<br>
Set-Cookie</p>
<p><strong>缓存</strong>相关的headers</p>
<p>Cache-Control Expires<br>
Last-Modified If-Modified-Since<br>
If-None-Match<br>
Etag</p>
<h3 id="http缓存">http缓存</h3>
<p>什么是缓存？<br>
为什么需要缓存？<br>
哪些资源可以被缓存？一静态资源（js css img)</p>
<h4 id="强缓存与协商缓存">强缓存与协商缓存</h4>
<p><strong>强缓存</strong>：</p>
<p>​		如果没有过期，浏览器可以直接使用该缓存而不需要重新向服务器请求</p>
<p>​		Expires 存在于响应头，为缓存过期时间点</p>
<p>​		Cache-Control 存在于响应头和请求头，为缓存过期时常</p>
<p><strong>Cache-Control</strong></p>
<p>Response Headers 中<br>
控制强制缓存的逻辑<br>
例如 Cache-Control:max-age=31536000(单位是秒）</p>
<p><strong>max-age</strong> 过期时长<br>
<strong>no-cache</strong> 不用强制缓存<br>
no-store 不用任何缓存</p>
<p>private 只允许最终用户缓存<br>
public 允许路由/代理缓存</p>
<p>Expires</p>
<p>同在 Response Headers 中<br>
同为控制缓存过期<br>
已被 Cache-Control 代替</p>
<p><strong>协商缓存</strong>：</p>
<p>​		不能直接使用该缓存，始终向服务器询问是否需要更新</p>
<p>服务器端缓存策略<br>
服务器判断客户端资源，是否和服务端资源一样<br>
一致则返回304,否则返回200和最新的资源</p>
<p>在Response Headers中，有两种</p>
<p><strong>Last-Modified</strong> 资源的最后修改时间<br>
<strong>Etag</strong> 资源的唯一标识（一个字符串，类似人类的指纹）</p>
<h3 id="版本">版本</h3>
<p>HTTP/0.9</p>
<ul>
<li>只有一个命令GET</li>
<li>响应类型: 仅超文本</li>
<li>没有header等描述数据的信息</li>
<li>服务器发送完毕，就关闭TCP连接</li>
</ul>
<p>HTTP/1.0</p>
<ul>
<li>增加了很多命令（post HESD ）</li>
<li>增加<code>status code</code> 和 <code>header</code></li>
<li>多字符集支持、多部分发送、权限、缓存等</li>
<li>响应：不再只限于超文本 (Content-Type 头部提供了传输 HTML 之外文件的能力 — 如脚本、样式或媒体文件)</li>
</ul>
<p>HTTP/1.1</p>
<ul>
<li>持久连接。TCP三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）</li>
<li>支持的方法: <code>GET</code> , <code>HEAD</code> , <code>POST</code> , <code>PUT</code> ,<code>DELETE</code> , <code>TRACE</code> , <code>OPTIONS</code></li>
<li>进行了重大的性能优化和特性增强，分块传输、压缩/解压、内容缓存磋商、虚拟主机（有单个IP地址的主机具有多个域名）、更快的响应，以及通过增加缓存节省了更多的带宽</li>
</ul>
<p>HTTP2</p>
<ul>
<li>所有数据以二进制传输。HTTP1.x是基于文本的，无法保证健壮性，HTTP2.0绝对使用新的二进制格式，方便且健壮</li>
<li>同一个连接里面发送多个请求不再需要按照顺序来</li>
<li>头信息压缩以及推送等提高效率的功能</li>
</ul>
<p>HTTP3</p>
<ul>
<li>QUIC“快速UDP互联网连接”（Quick UDP Internet Connections）</li>
</ul>
<p>HTTP3 的主要改进在传输层上。传输层不会再有我前面提到的那些繁重的 TCP 连接了。现在，一切都会走 UDP。</p>
<h3 id="hsts">HSTS</h3>
<p>HTTP Strict Transport Security，简单说就是强制客户端使用 HTTPS 访问页面</p>
<p>原理：</p>
<ul>
<li>在服务器响应头中添加 <code>Strict-Transport-Security</code>，可以设置 <code>max-age</code></li>
<li>用户访问时，服务器种下这个头</li>
<li>下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码</li>
<li>变成 https 访问源服务器</li>
</ul>
<h3 id="http协议特点">HTTP协议特点</h3>
<ol>
<li>支持客户/服务器模式。</li>
<li>简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h3 id="tcp">TCP</h3>
<p>TCP(Transmission Control Protocol)传输控制协议</p>
<p>TCP/IP协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层</p>
<h4 id="连接三次握手">连接三次握手</h4>
<p>第一次握手：主机A发送位码为<code>SYN＝1</code>，随机产生<code>Seq number=1234567</code>的数据包到服务器，主机B由<code>SYN=1</code>知道，A要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</p>
<p>第二次握手：主机B收到请求后要确认联机信息，向A发送<code>ack number=(主机A的seq+1)</code>，<code>SUN=1，ACK=1234567 + 1</code>，随机产生<code>Seq=7654321</code>的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</p>
<p>第三次握手：主机A收到后检查<code>ack number</code>是否正确，即第一次发送的<code>seq number+1</code>，以及位码<code>SYN</code>是否为1，若正确，主机A会再发送<code>ack number=(主机B的seq+1)</code>，<code>ack=7654321 + 1</code>，主机B收到后确认<code>Seq</code>值与<code>ACK=7654321+ 1</code>则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</p>
<h4 id="断开四次分手">断开四次分手</h4>
<p>刚开始双方都处于established状态，假如是客户端先发起关闭请求</p>
<p>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态</p>
<p>第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态</p>
<p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态</p>
<p>需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p>
<h2 id="开发环境">开发环境</h2>
<p>git</p>
<p>常用git命令</p>
<p>git add .    添加<br>
git checkout xxx     还原<br>
git commit - m &quot; xxx &quot;    提交<br>
git push origin master    推送<br>
git pull origin master    拉去<br>
git branch    分支<br>
git checkout -b xxx  新建分支 / git checkout XXX    切换分支<br>
git merge xxx    合并分支<br>
git stash   暂存   git stash pop   恢复暂存</p>
<p>抓包</p>
<p>移动端h5页，查看网络请求，需要用工具抓包<br>
windows 一般用 fiddler<br>
Mac OS 一般用 charles</p>
<p>webpack babel</p>
<p>ES6模块化，浏览器暂不支持<br>
ES6语法，浏览器并不完全支持<br>
压缩代码，整合代码，以让网页加载更快</p>
<h2 id="运行环境">运行环境</h2>
<p>运行环境即浏览器（server端有nodejs)<br>
下载网页代码，渲染出页面，期间会执行若干JS<br>
要保证代码在浏览器中：稳定且高效</p>
<h3 id="网页加载过程">网页加载过程</h3>
<p>加载资源的<strong>形式</strong></p>
<p>html代码<br>
媒体文件，如图片、视频等<br>
javascript css</p>
<p><strong>加载过程</strong></p>
<p>DNS解析：域名-&gt;IP地址<br>
浏览器根据IP地址向服务器发起http请求<br>
服务器处理http请求，并返回给浏览器</p>
<p><strong>渲染</strong>过程</p>
<p>根据HTML代码生成DOM Tree<br>
根据CSS代码生成CSSOM<br>
将DOM Tree和CSSOM整合行程Render Tree<br>
根据Render Tree 渲染页面<br>
遇到&lt;script&gt;则暂停渲染，优先加载并执行JS代码，完成再继续<br>
直至把 Render Tree 渲染完成</p>
<h4 id="页面渲染">页面渲染</h4>
<p>HTML生成<strong>DOM</strong>树，CSS生成<strong>对象模型</strong>(<strong>CSSDOM</strong>)</p>
<p>DOM树与CSSDOM合并生成<strong>渲染树</strong></p>
<p>浏览器根据渲染树计算后生成<strong>布局树</strong>Layout Tree</p>
<p>最后将画面绘制到屏幕上</p>
<p><strong>window.onload 和 DOMContentLoaded 区别</strong></p>
<p>window.onload资源全部加载完才能执行，包括图片<br>
DOMContentLoaded DOM 渲染完成即可，图片可能尚未下载</p>
<h4 id="性能优化">性能优化</h4>
<p>是一个综合性问题，没有标准答案，但要求尽量全面<br>
某些细节问题可能会单独提问：手写防抖、节流</p>
<p><strong>性能优化原则</strong></p>
<p>多使用内存、缓存或其他方法<br>
减少CPU计算量，减少网络加载耗时<br>
(适用于所有编程的性能优化——空间换时间）</p>
<p><strong>让加载更快</strong><br>
减少资源体积：压缩代码<br>
减少访问次数：合并代码，SSR服务器端渲染，缓存<br>
使用更快的网络：CDN</p>
<p><strong>缓存</strong><br>
静态资源加 hash 后缀，根据文件内容计算 hash<br>
文件内容不变，则hash不变，则url不变<br>
url和文件不变，则会自动触发http缓存机制，返回304</p>
<p><strong>SSR</strong><br>
服务器端渲染：将网页和数据一起加载，一起渲染<br>
非SSR(前后端分离）:先加载网页，再加载数据，再渲染数据<br>
早先的JSP ASP PHP,现在的vue React SSR</p>
<p><strong>让渲染更快</strong><br>
CSS 放在 head ,JS 放在 body 最下面<br>
尽早开始执行JS,用DOMContentLoaded触发<br>
懒加载（图片懒加载，上滑加载更多）<br>
对DOM查询进行缓存<br>
频繁DOM操作，合并到一起插入DOM结构<br>
<strong>节流 throttle</strong> <strong>防抖 debounce</strong></p>
<pre><code class="language-javascript">const p = document.getElementsByTagName('p');
</code></pre>
<p><strong>防抖 debounce</strong></p>
<p>监听一个输入框的，文字变化后触发change事件<br>
直接用keyup事件，则会频发触发change事件<br>
防抖：用户输入结束或暂停时，才会触发change事件</p>
<pre><code class="language-javascript">const debounce = (fn: Function, delay: number = 500): EventListener =&gt; {
    let timer: NodeJS.Timeout;
    return function () {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            //@ts-ignore
            fn.apply(this, arguments);
        }, delay)
    }
}

p[0].addEventListener('click', debounce(function () {
    console.log(p[0]);
}, 600))
</code></pre>
<p><strong>节流 throttle</strong></p>
<p>拖拽一个元素时，要随时拿到该元素被拖拽的位置<br>
直接用drag事件，则会频发触发，很容易导致卡顿<br>
节流：无论拖拽速度多快，都会每隔100ms触发一次</p>
<pre><code class="language-javascript">const throttle = (fn: Function, delay: number = 100): EventListener =&gt; {
    let timer: NodeJS.Timeout | null = null;
    return function () {
        if (timer) return;
        timer = setTimeout(() =&gt; {
            //@ts-ignore
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}


p[0].addEventListener('drag', throttle(
    function (e: any) {
        console.log(e.offsetX, e.offsetY)
    }, 500)
);
</code></pre>
<h3 id="浏览器">浏览器</h3>
<h4 id="url">URL</h4>
<p>协议://主(ex.com)机:端口/路(a/b)径 ?查询(k=v&amp;k=v)参数#锚点</p>
<h4 id="dns">DNS</h4>
<p>从域名获取IP地址</p>
<p>根域名服务器，顶级域名服务器，主域名服务器</p>
<p>递归查询</p>
<p>​		客户端只发一次请求，要求对方给出最终结果。</p>
<p>​		浏览器缓存，系统缓存，路由器缓存，ISP(运营商)DNS缓存：统称为DNS高速缓存</p>
<p>​		若当前DNS服务器没有，则服务器会继续向其他DNS服务器查询</p>
<p>迭代查询</p>
<p>​		客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</p>
<p>​		当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
<h3 id="安全">安全</h3>
<p><strong>XSS跨站请求攻击</strong></p>
<p>一个博客网站，我发表一篇博客，其中嵌入&lt;script&gt;脚本<br>
脚本内容：获取cookie,发送到我的服务器（服务器配合跨域）<br>
发布这篇博客，有人查看它，窃取访问者的cookie</p>
<p><strong>XSS 预防</strong>(xss 工具)</p>
<p>替换特殊字符，如&lt;变为&lt;&gt;变为&gt;<br>
&lt;script&gt;变为 &amp;lt;script&amp;gt;,直接显示，而不会作为脚本执行<br>
前端要替换，后端也要替换，都做总不会有错</p>
<p><strong>XSRF跨站请求伪造</strong></p>
<p>你正在购物，看中了某个商品，商品id是100<br>
付费接口是xxx.com/pay?id=100,但没有任何验证<br>
我是攻击者，我看中了一个商品，id是200<br>
我向你发送一封电子邮件，邮件标题很吸引人<br>
但邮件正文隐藏着&lt;img src=xxx.com/pay?id=200/&gt;<br>
你一查看邮件，就帮我购买了id是200的商品</p>
<p><strong>XSRF 预防</strong></p>
<p>使用post接口<br>
增加验证，例如密码、短信验证码、指纹等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA+WindowBuilder+MySQL实现饭店管理系统]]></title>
        <id>https://DDC777.github.io/post/javawindowbuildermysql-shi-xian-fan-dian-guan-li-xi-tong/</id>
        <link href="https://DDC777.github.io/post/javawindowbuildermysql-shi-xian-fan-dian-guan-li-xi-tong/">
        </link>
        <updated>2021-07-19T00:49:40.000Z</updated>
        <content type="html"><![CDATA[<p>本项目为我的大二课程设计项目，仅供学习使用！</p>
<p><strong>目 录</strong></p>
<p><a href="#_Toc77372815">1   项目概述... 1</a></p>
<p><a href="#_Toc77372816">2   需求分析... 2</a></p>
<p><a href="#_Toc77372817">2.1   总体目标... 2</a></p>
<p><a href="#_Toc77372818">2.2   具体目标... 2</a></p>
<p><a href="#_Toc77372819">2.3   系统功能建模... 2</a></p>
<p><a href="#_Toc77372820">2.3.1   系统数据流程图... 2</a></p>
<p><a href="#_Toc77372821">2.3.2   数据字典... 3</a></p>
<p><a href="#_Toc77372822">2.4   系统数据模型... 4</a></p>
<p><a href="#_Toc77372823">3   概要设计... 6</a></p>
<p><a href="#_Toc77372824">3.1   体系结构设计... 6</a></p>
<p><a href="#_Toc77372825">3.2   数据库设计... 6</a></p>
<p><a href="#_Toc77372826">3.2.1   关系模式设计... 6</a></p>
<p><a href="#_Toc77372827">3.2.2   物理表结构设计... 7</a></p>
<p><a href="#_Toc77372828">4   详细设计... 10</a></p>
<p><a href="#_Toc77372829">4.1   登录模块... 10</a></p>
<p><a href="#_Toc77372830">4.2   点餐模块... 11</a></p>
<p><a href="#_Toc77372831">5   系统实现... 12</a></p>
<p><a href="#_Toc77372832">5.1   实现技术... 12</a></p>
<p><a href="#_Toc77372833">5.2   应用程序配置... 12</a></p>
<p><a href="#_Toc77372834">5.3   业务逻辑代码... 12</a></p>
<p><a href="#_Toc77372835">5.4   数据库代码... 23</a></p>
<p><a href="#_Toc77372836">6   结束语... 29</a></p>
<p><a href="#_Toc77372837">7   参考文献... 30</a></p>
<h1 id="1-项目概述">1    项目概述</h1>
<p>本项目是一个饭店管理系统。</p>
<p>主要实现了用户的登录，开台，点餐，结算等功能。</p>
<p>管理端实现了订单管理，餐台管理，用户管理和菜品管理。</p>
<p>可以利用本系统对餐厅，饭店的点餐，订单和菜品进行系统的管理，提升饭店餐厅的管理效率。</p>
<p>主程序和GUI：使用IDEA开发的JAVA程序</p>
<p>数据库：使用Navicat管理的MySQL数据库</p>
<p>连接：使用JDBC驱动进行数据库与Java程序连接</p>
<h1 id="2-需求分析">2    需求分析</h1>
<h2 id="21-总体目标">2.1 总体目标</h2>
<p>系统目标：</p>
<p>1.窗体界面设计友好、美观</p>
<p>2.基本信息管理方便、快捷</p>
<p>3.具有良好的数据查询功能,方便管理员和用户的操作</p>
<p>4.系统运行稳定、系统数据安全可靠</p>
<p>5.最大限度地实现系统的易维护性和易操作性</p>
<h2 id="22-具体目标">2.2 具体目标</h2>
<p>具体目标：</p>
<p>1.登录：输入账户名和密码，进行登录。</p>
<p>2.基本信息管理：用户管理,餐台管理，菜品分类管理,菜品管理。</p>
<p>3.点餐管理：点餐（开台点餐，点餐信息增删改查）</p>
<p>4.结算管理：结算，结算后餐台空闲</p>
<p>5.统计查询：菜品销售查询，收入统计</p>
<h2 id="23-系统功能建模">2.3 系统功能建模</h2>
<h3 id="231-系统数据流程图">2.3.1      系统数据流程图</h3>
<p>详细数据流图如图2-1所示。</p>
<figure data-type="image" tabindex="1"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img" loading="lazy"></figure>
<p>图 2‑1</p>
<p>此DFD图有两个接口，分别是用户和管理员</p>
<p>用户输出：订座信息，点餐信息，付款信息</p>
<p>管理员输出：用户管理信息，菜品变动信息，餐台管理信息，订单管理信息</p>
<p>用户收到：餐台信息，菜品信息，发票信息，用户状态信息</p>
<p>管理员收到：销售数据</p>
<h3 id="232-数据字典">2.3.2      数据字典</h3>
<p>数据字典如图 2-2所示。</p>
<figure data-type="image" tabindex="2"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif" alt="img" loading="lazy"></figure>
<p>图 2‑2</p>
<p>主要数据有：用户信息、管理员信息，菜品信息，餐台信息，菜单信息</p>
<p>这些数据分别存储于用户数据库、管理员数据库、菜品数据库、餐台数据库、菜单数据库</p>
<h2 id="24-系统数据模型">2.4 系统数据模型</h2>
<p>系统数据模型，即E-R图，如图 2-3所示。</p>
<figure data-type="image" tabindex="3"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif" alt="img" loading="lazy"></figure>
<p>图 2‑3</p>
<p>实体有：用户，订单，菜单，菜品，餐台，管理员</p>
<p>实体关系：</p>
<p>用户-点餐-订单：一对多</p>
<p>订单-占用-餐台：一对一</p>
<p>订单-关联-菜单：一对多</p>
<p>菜单-包含-菜品：多对多</p>
<p>管理员-处理-餐台/菜单：三实体多对多</p>
<h1 id="3-概要设计">3    概要设计</h1>
<h2 id="31-体系结构设计">3.1 体系结构设计</h2>
<p>系统功能模块图如图 3-1所示。</p>
<figure data-type="image" tabindex="4"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image008.gif" alt="img" loading="lazy"></figure>
<p>图 3‑1</p>
<p>饭店管理系统分用户和管理员两个模块。</p>
<p>用户模块中又包含订座、点餐、结账三个模块；</p>
<p>前两个对应了餐台选择和菜品选择模块。</p>
<p>管理员模块中包含用户管理，菜品管理和订单管理模块</p>
<p>分别包含注册、删除；菜品、库存增删；订单取消、删除模块。</p>
<h2 id="32-数据库设计">3.2 数据库设计</h2>
<h3 id="321-关系模式设计">3.2.1      关系模式设计</h3>
<p>User (UID, UName, Password, Tele, Point)</p>
<p>Admin (AID, AName, Password, Tele)</p>
<p>Order (OID, SID, OMID, Note, Price, isPay)</p>
<p>OrderMenu (OMID, OID, FID)</p>
<p>Seat (SID, Anum,State)</p>
<p>Food (FID, FName, Class, Price, Inventory)</p>
<h3 id="322-物理表结构设计">3.2.2      物理表结构设计</h3>
<p>管理员设计参数见表 3-1所示。</p>
<p>表 3‑1 管理员表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>管理员ID</td>
<td>AID</td>
<td>Int</td>
<td>2</td>
<td>主键</td>
</tr>
<tr>
<td>管理员名</td>
<td>AName</td>
<td>Varchar</td>
<td>20</td>
<td>非空</td>
</tr>
<tr>
<td>密码</td>
<td>Password</td>
<td>Varchar</td>
<td>30</td>
<td>非空</td>
</tr>
<tr>
<td>电话</td>
<td>Tele</td>
<td>Char</td>
<td>11</td>
<td></td>
</tr>
</tbody>
</table>
<p>用户设计参数见表 3-2所示。</p>
<p>表 3‑2 用户表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户ID</td>
<td>UID</td>
<td>Int</td>
<td>10</td>
<td>主键</td>
</tr>
<tr>
<td>用户名</td>
<td>UName</td>
<td>Varchar</td>
<td>20</td>
<td>非空</td>
</tr>
<tr>
<td>密码</td>
<td>Password</td>
<td>Varchar</td>
<td>30</td>
<td>非空</td>
</tr>
<tr>
<td>电话</td>
<td>Tele</td>
<td>Char</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>积分</td>
<td>Point</td>
<td>Int</td>
<td>225</td>
<td></td>
</tr>
</tbody>
</table>
<p>餐台设计参数见表 3-3所示。</p>
<p>表 3‑3 餐台表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐台号</td>
<td>SID</td>
<td>Int</td>
<td>3</td>
<td>主键</td>
</tr>
<tr>
<td>座位数</td>
<td>Anum</td>
<td>Int</td>
<td>2</td>
<td>非空</td>
</tr>
<tr>
<td>是否空闲</td>
<td>State</td>
<td>Int</td>
<td>1</td>
<td>非空</td>
</tr>
</tbody>
</table>
<p>菜品设计参数见表 3-4所示。</p>
<p>表 3‑4 菜品表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>菜品ID</td>
<td>FID</td>
<td>Int</td>
<td>4</td>
<td>主键</td>
</tr>
<tr>
<td>菜品名</td>
<td>FName</td>
<td>Varchar</td>
<td>20</td>
<td>非空</td>
</tr>
<tr>
<td>类别</td>
<td>Class</td>
<td>Varchar</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>价格</td>
<td>Price</td>
<td>Decimal</td>
<td>5-2</td>
<td></td>
</tr>
<tr>
<td>库存</td>
<td>Inventory</td>
<td>Int</td>
<td>5</td>
<td></td>
</tr>
</tbody>
</table>
<p>订单设计参数见表 3-5所示。</p>
<p>表 3‑5 订单表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>订单号</td>
<td>OID</td>
<td>Int</td>
<td>10</td>
<td>主键</td>
</tr>
<tr>
<td>备注</td>
<td>Note</td>
<td>Varchar</td>
<td>225</td>
<td></td>
</tr>
<tr>
<td>价格</td>
<td>Price</td>
<td>Decimal</td>
<td>10-2</td>
<td></td>
</tr>
<tr>
<td>付款状态</td>
<td>isPay</td>
<td>Int</td>
<td>1</td>
<td>非空</td>
</tr>
<tr>
<td>座位号</td>
<td>SID</td>
<td>Int</td>
<td>3</td>
<td>外键</td>
</tr>
</tbody>
</table>
<p>菜单设计参数见表 3-6所示。</p>
<p>表 3‑6 菜单表</p>
<table>
<thead>
<tr>
<th>列含义</th>
<th>列标示</th>
<th>类型</th>
<th>长度</th>
<th>完整性约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>菜号</td>
<td>OMID</td>
<td>Int</td>
<td>10</td>
<td>主键</td>
</tr>
<tr>
<td>订单号</td>
<td>OID</td>
<td>Int</td>
<td>10</td>
<td>外键</td>
</tr>
<tr>
<td>菜品号</td>
<td>FID</td>
<td>Int</td>
<td>4</td>
<td>外键</td>
</tr>
</tbody>
</table>
<h1 id="4-详细设计">4    详细设计</h1>
<h2 id="41-登录模块">4.1 登录模块</h2>
<p>登录模块如图 4-1所示。</p>
<figure data-type="image" tabindex="5"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif" alt="img" loading="lazy"></figure>
<p>图 4‑1</p>
<p>在登录时，先判断是否为管理员，若为管理员，直接进行登录验证，否则调用用户管理系统操作。输入账号密码时，先后判断是否为空，账号是否存在，密码是否对应。当都通过时，登录成功，否则重新输入。</p>
<h2 id="42-点餐模块">4.2 点餐模块</h2>
<p>点餐模块如图 4-2所示。</p>
<figure data-type="image" tabindex="6"><img src="file:///C:/Users/DDC/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif" alt="img" loading="lazy"></figure>
<p>图 4‑2</p>
<p>点餐时，先查看并选择数据库中的菜品，然后将菜品添加到清单中，进行确认订单后，将清单信息更新到订单数据库</p>
<h1 id="5-系统实现">5    系统实现</h1>
<h2 id="51-实现技术">5.1 实现技术</h2>
<p>使用Ecilpse + WindowBuilder进行GUI和JAVA程序的开发</p>
<p>使用Navicat对MYSQL数据库进行管理</p>
<h2 id="52-应用程序配置">5.2 应用程序配置</h2>
<p>JAVASE 1.7的开发及运行环境</p>
<p>MYSQL数据库版本为5.7.33</p>
<p>5.1.47的JDBC驱动进行JAVA程序和数据库的连接</p>
<h2 id="53-业务逻辑代码">5.3 业务逻辑代码</h2>
<p><strong>Hms.model:</strong></p>
<p>*<strong>LoginContrl.Java*</strong></p>
<p>//登录控制</p>
<p>package hms.model;</p>
<p>import java.sql.*;</p>
<p>import hms.util.DBUtil;</p>
<p>public class LoginControl {</p>
<p>public static boolean isAdmin;</p>
<p>public static int id;</p>
<p>//验证密码</p>
<p>public static boolean LoginCheck(boolean isAdmin, int id, String password) throws ClassNotFoundException, SQLException {</p>
<p>​     String SQL = &quot;SELECT password FROM &quot;;</p>
<p>​     if (!isAdmin) {</p>
<p>​        SQL = SQL + &quot;<code>user</code> where uid = &quot; + id;</p>
<p>​     } else {</p>
<p>​        isAdmin = true;</p>
<p>​        SQL = SQL + &quot;<code>admin</code> where aid = &quot; + id;</p>
<p>​     }</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     if (!resultSet.next()) {</p>
<p>​        try {</p>
<p>​            DBUtil.closeConnection();</p>
<p>​        } catch (Exception e) {</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​        return false;</p>
<p>​     } else if (!resultSet.getObject(&quot;password&quot;).equals(password)) {</p>
<p>​        try {</p>
<p>​            DBUtil.closeConnection();</p>
<p>​        } catch (Exception e) {</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​        return false;</p>
<p>​     }</p>
<p>​     try {</p>
<p>​        DBUtil.closeConnection();</p>
<p>​     } catch (Exception e) {</p>
<p>​        e.printStackTrace();</p>
<p>​     }</p>
<p>​     LoginControl.id = id;</p>
<p>​     try {</p>
<p>​        ReadInformation();</p>
<p>​     } catch (Exception e) {</p>
<p>​        e.printStackTrace();</p>
<p>​     }</p>
<p>​     System.out.println(&quot;\nSucesss!\nisAdmin:&quot; + isAdmin + &quot;\nid:&quot; + LoginControl.id);</p>
<p>​     return true;</p>
<p>}</p>
<p>//信息读入</p>
<p>public static void ReadInformation() throws Exception {</p>
<p>​     if (isAdmin) {</p>
<p>​     } else {</p>
<p>​        User.userInformationRead(id);</p>
<p>​     }</p>
<p>}</p>
<p>}</p>
<p>*<strong>Seat.Java*</strong></p>
<p>//餐台管理</p>
<p>package hms.model;</p>
<p>import java.sql.*;</p>
<p>import hms.util.DBUtil;</p>
<p>public class Seat {</p>
<p>public static int[] SID = new int[100];</p>
<p>public static int[] Anum = new int[100];</p>
<p>public static int[] State = new int[100];</p>
<p>public static int USID;</p>
<p>public static int UAnum;</p>
<p>//座位获取</p>
<p>public static void getSeats() throws Exception {</p>
<p>​     String SQL = &quot;SELECT * FROM seat&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     for (int i = 1; resultSet.next(); i++) {</p>
<p>​        SID[i] = resultSet.getInt(&quot;SID&quot;);</p>
<p>​        Anum[i] = resultSet.getInt(&quot;Anum&quot;);</p>
<p>​        State[i] = resultSet.getInt(&quot;State&quot;);</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>//剩余座位量获取</p>
<p>public static int remainingSeats(int Anum) throws Exception {</p>
<p>​     int num = 0;</p>
<p>​     String SQL = &quot;SELECT * FROM seat where Anum =&quot;;</p>
<p>​     SQL = SQL + &quot; &quot; + Anum;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        if(resultSet.getInt(&quot;State&quot;) == 0) {</p>
<p>​            num++;</p>
<p>​        }</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     return num;</p>
<p>}</p>
<p>//确认座位</p>
<p>public static boolean SeatConfirm() throws Exception {</p>
<p>​     String SQL = &quot;SELECT * FROM seat WHERE Anum = &quot;;</p>
<p>​     SQL = SQL + UAnum + &quot; AND State = 0&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     resultSet.next();</p>
<p>​     try {</p>
<p>​        USID = resultSet.getInt(&quot;SID&quot;);</p>
<p>​     } catch (Exception e) {</p>
<p>​        return false;</p>
<p>​     }</p>
<p>​     String SQL2 = &quot;UPDATE seat SET State = 1 WHERE SID = &quot;;</p>
<p>​     SQL2 = SQL2 + USID;</p>
<p>​     DBUtil.update(SQL2);</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     return true;</p>
<p>}</p>
<p>//座位状态更改</p>
<p>public static void StateChange(int State,int SID) throws Exception {</p>
<p>​     String SQL = &quot;UPDATE seat SET State = &quot;;</p>
<p>​     SQL = SQL + State +&quot; WHERE SID = &quot;+ SID;</p>
<p>​     DBUtil.update(SQL);</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>}</p>
<p>*<strong>Food.Java*</strong></p>
<p>//菜品管理</p>
<p>package hms.model;</p>
<p>import java.sql.ResultSet;</p>
<p>import javax.swing.ImageIcon;</p>
<p>import hms.util.DBUtil;</p>
<p>import hms.view.OrderFrame;</p>
<p>public class Food {</p>
<p>//菜名获取</p>
<p>public static String[] getFoodsName(String Class) throws Exception {</p>
<p>​     String[] list = new String[20];</p>
<p>​     String SQL = &quot;SELECT FName FROM Food WHERE Class like '&quot;;</p>
<p>​     SQL = SQL + Class +&quot;'&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     for (int i = 0; resultSet.next(); i++) {</p>
<p>​        list[i] = resultSet.getString(&quot;FName&quot;);</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     return list;</p>
<p>}</p>
<p>//菜品图片读入</p>
<p>public static ImageIcon getIcon(int FID) {</p>
<p>​     try {</p>
<p>​        ImageIcon testtt = new ImageIcon(OrderFrame.class.getResource(&quot;/img/&quot; + FID + &quot;.jpg&quot;));</p>
<p>​     } catch (Exception e) {</p>
<p>​        return null;</p>
<p>​     }</p>
<p>​     ImageIcon icon = new ImageIcon(OrderFrame.class.getResource(&quot;/img/&quot; + FID + &quot;.jpg&quot;));</p>
<p>​     return icon;</p>
<p>}</p>
<p>public static int CFid = 1;</p>
<p>public static String CFName = &quot;红烧肉&quot;;</p>
<p>public static float CFPrice = (float) 18.00;</p>
<p>public static int CFInventory = 35;</p>
<p>public static int allPrice = 0;</p>
<p>//菜品选择</p>
<p>public static void foodChoose(String FName) throws Exception {</p>
<p>​     String SQL = &quot;SELECT * FROM Food WHERE FName like '&quot;;</p>
<p>​     SQL = SQL + FName +&quot;'&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        CFid = resultSet.getInt(&quot;FID&quot;);</p>
<p>​        CFName = resultSet.getString(&quot;FName&quot;);</p>
<p>​        CFPrice = resultSet.getInt(&quot;Price&quot;);</p>
<p>​        CFInventory = resultSet.getInt(&quot;Inventory&quot;);</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>public static String[] orderStrings = new String[20];</p>
<p>public static int listNum = 0;</p>
<p>//菜单添加菜品</p>
<p>public static void addFood() {</p>
<p>​     orderStrings[listNum] = CFName;</p>
<p>​     listNum++;</p>
<p>​     allPrice += CFPrice;</p>
<p>}</p>
<p>}</p>
<p>*<strong>Order.Java*</strong></p>
<p>//订单管理</p>
<p>package hms.model;</p>
<p>import java.sql.ResultSet;</p>
<p>import hms.util.DBUtil;</p>
<p>public class Order {</p>
<p>public static int OID;</p>
<p>//创建订单</p>
<p>public static void creatOrder() throws Exception {</p>
<p>​     int lastOID = 0;</p>
<p>​     String SQL = &quot;SELECT OID FROM <code>order</code> ORDER BY OID&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        lastOID = resultSet.getInt(1);</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     System.out.println(lastOID);</p>
<p>​     OID = lastOID + 1;</p>
<p>​     String SQL2 = &quot;INSERT INTO <code>order</code> (OID,isPay,SID) VALUES ('&quot;;</p>
<p>​     SQL2 = SQL2 + OID + &quot;','0','&quot; + Seat.USID + &quot;')&quot;;</p>
<p>​     DBUtil.update(SQL2);</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>public static int OMID;</p>
<p>//上传订单和菜单</p>
<p>public static void updateOrder() throws Exception {</p>
<p>​     int lastOMID = 0;</p>
<p>​     String SQL = &quot;SELECT OMID FROM <code>ordermenu</code> ORDER BY OMID&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        lastOMID = resultSet.getInt(1);</p>
<p>​     }</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     System.out.println(lastOMID);</p>
<p>​     OMID = lastOMID + 1;</p>
<p>​     for (int i = 0; Food.orderStrings[i] != null; i++) {</p>
<p>​        int FID = 0;</p>
<p>​        String SQL3 = &quot;SELECT FID FROM Food WHERE FName like '&quot;;</p>
<p>​        SQL3 = SQL3 + Food.orderStrings[i] + &quot;'&quot;;</p>
<p>​        ResultSet resultSet2 = DBUtil.query(SQL3);</p>
<p>​        while (resultSet2.next()) {</p>
<p>​            FID = resultSet2.getInt(&quot;FID&quot;);</p>
<p>​        }</p>
<p>​        String SQL2 = &quot;INSERT INTO <code>ordermenu</code> (OMID,FID,OID) VALUES ('&quot;;</p>
<p>​        SQL2 = SQL2 + OMID + &quot;','&quot; + FID + &quot;','&quot; + OID + &quot;')&quot;;</p>
<p>​        DBUtil.update(SQL2);</p>
<p>​        OMID++;</p>
<p>​        DBUtil.closeConnection();</p>
<p>​     }</p>
<p>​     String SQL4 = &quot;UPDATE <code>order</code> SET Price =&quot;;</p>
<p>​     SQL4 = SQL4 + Food.allPrice + &quot; WHERE OID = &quot; + OID;</p>
<p>​     DBUtil.update(SQL4);</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>//结算处理</p>
<p>public static void payDeal() throws Exception {</p>
<p>​     String SQL = &quot;UPDATE <code>order</code> SET isPay = 1 WHERE OID = &quot;;</p>
<p>​     SQL = SQL + OID;</p>
<p>​     DBUtil.update(SQL);</p>
<p>​     DBUtil.closeConnection();</p>
<p>​     String SQL2 = &quot;UPDATE <code>user</code> SET Point = Point + &quot;;</p>
<p>​     SQL2 = SQL2 + Food.allPrice + &quot; WHERE UID = &quot; + User.UID;</p>
<p>​     DBUtil.update(SQL2);</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>//根据订单号获取座位号</p>
<p>public static int getSID(int OID) throws Exception {</p>
<p>​     int SID = 0;</p>
<p>​     String SQL = &quot;SELECT SID FROM <code>order</code> where OID = &quot;;</p>
<p>​     SQL = SQL + OID;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        SID = resultSet.getInt(1);</p>
<p>​     }</p>
<p>​     return SID;</p>
<p>}</p>
<p>//订单删除</p>
<p>public static void OrderDelet(int OID) throws Exception {</p>
<p>​     String SQL = &quot;DELETE FROM <code>order</code> WHERE OID = &quot;;</p>
<p>​     SQL = SQL + OID;</p>
<p>​     DBUtil.update(SQL);</p>
<p>​     DBUtil.closeConnection();</p>
<p>}</p>
<p>//获取总营业额</p>
<p>public static float getTotalTurnover() throws Exception {</p>
<p>​     float TotalTurnover = 0;</p>
<p>​     String SQL = &quot;SELECT Price From <code>order</code>&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        TotalTurnover += resultSet.getFloat(1);</p>
<p>​     }</p>
<p>​     return TotalTurnover;</p>
<p>}</p>
<p>//获取总销量</p>
<p>public static int getTotalSales() throws Exception {</p>
<p>​     int TotalSales = 0;</p>
<p>​     String SQL = &quot;SELECT OMID From <code>ordermenu</code>&quot;;</p>
<p>​     ResultSet resultSet = DBUtil.query(SQL);</p>
<p>​     while (resultSet.next()) {</p>
<p>​        TotalSales++;</p>
<p>​     }</p>
<p>​     return TotalSales;</p>
<p>}</p>
<p>}</p>
<h2 id="54-数据库代码">5.4 数据库代码</h2>
<p><strong>Hms.util</strong></p>
<p>*<strong>DBUtil.Java*</strong></p>
<p>//数据库连接与操作的抽象</p>
<p>package hms.util;</p>
<p>import java.sql.*;</p>
<p>public class DBUtil {</p>
<p>public static final String DBDRIVER = &quot;com.mysql.jdbc.Driver&quot;;</p>
<p>public static final String DBURL = &quot;jdbc:mysql://localhost:3306/resmsc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;;</p>
<p>public static final String DBUSER = &quot;LNTU_DDC&quot;;</p>
<p>public static final String DBPASS = &quot;jtcsm&quot;;</p>
<p>public static Connection connection = null;</p>
<p>//获取并返回连接</p>
<p>public static Connection getConnection() throws ClassNotFoundException, SQLException {</p>
<p>​     Connection con = null;</p>
<p>​     try {</p>
<p>​        Class.forName(DBDRIVER);</p>
<p>​     } catch (ClassNotFoundException e) {</p>
<p>​        e.printStackTrace();</p>
<p>​     }</p>
<p>​     try {</p>
<p>​        con = DriverManager.getConnection(DBURL, DBUSER, DBPASS);</p>
<p>​     } catch (SQLException e) {</p>
<p>​        e.printStackTrace();</p>
<p>​     }</p>
<p>​     System.out.println(&quot;connect to db&quot;);</p>
<p>​     return con;</p>
<p>}</p>
<p>//数据库查找</p>
<p>public static ResultSet query(String sql) throws ClassNotFoundException, SQLException {</p>
<p>​     connection = getConnection();</p>
<p>​     Statement statement = connection.createStatement();</p>
<p>​     ResultSet resultSet = statement.executeQuery(sql);</p>
<p>​     return resultSet;</p>
<p>}</p>
<p>//数据库更新</p>
<p>public static int update(String sql) throws ClassNotFoundException, SQLException {</p>
<p>​     connection = getConnection();</p>
<p>​     Statement statement = connection.createStatement();</p>
<p>​     int UpdateLine = statement.executeUpdate(sql);</p>
<p>​     return UpdateLine;</p>
<p>}</p>
<p>//关闭连接</p>
<p>public static void closeConnection() throws Exception {</p>
<p>​     connection.close();</p>
<p>}</p>
<p>}</p>
<p><strong>SQL****建表语句</strong></p>
<p><strong>Admin</strong></p>
<p>DROP TABLE IF EXISTS <code>admin</code>;</p>
<p>CREATE TABLE <code>admin</code> (</p>
<p><code>AID</code> int(2) NOT NULL,</p>
<p><code>AName</code> varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</p>
<p><code>Password</code> varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</p>
<p><code>Tele</code> char(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>AID</code>) USING BTREE</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p><strong>Food</strong></p>
<p>DROP TABLE IF EXISTS <code>food</code>;</p>
<p>CREATE TABLE <code>food</code> (</p>
<p><code>FID</code> int(4) NOT NULL,</p>
<p><code>FName</code> varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</p>
<p><code>Class</code> varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</p>
<p><code>Price</code> decimal(5, 2) NULL DEFAULT NULL,</p>
<p><code>Inventory</code> int(5) NULL DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>FID</code>) USING BTREE</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p><strong>Order</strong></p>
<p>DROP TABLE IF EXISTS <code>order</code>;</p>
<p>CREATE TABLE <code>order</code> (</p>
<p><code>OID</code> int(10) NOT NULL,</p>
<p><code>Note</code> varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</p>
<p><code>Price</code> decimal(10, 2) NULL DEFAULT NULL,</p>
<p><code>isPay</code> int(1) NOT NULL,</p>
<p><code>SID</code> int(3) NULL DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>OID</code>) USING BTREE,</p>
<p>INDEX <code>SID</code>(<code>SID</code>) USING BTREE,</p>
<p>CONSTRAINT <code>SID</code> FOREIGN KEY (<code>SID</code>) REFERENCES <code>seat</code> (<code>SID</code>) ON DELETE SET NULL ON UPDATE RESTRICT</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p><strong>Ordermenu</strong></p>
<p>DROP TABLE IF EXISTS <code>ordermenu</code>;</p>
<p>CREATE TABLE <code>ordermenu</code> (</p>
<p><code>OMID</code> int(10) NOT NULL,</p>
<p><code>FID</code> int(4) NULL DEFAULT NULL,</p>
<p><code>OID</code> int(10) NULL DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>OMID</code>) USING BTREE,</p>
<p>INDEX <code>FID</code>(<code>FID</code>) USING BTREE,</p>
<p>INDEX <code>OID</code>(<code>OID</code>) USING BTREE,</p>
<p>CONSTRAINT <code>FID</code> FOREIGN KEY (<code>FID</code>) REFERENCES <code>food</code> (<code>FID</code>) ON DELETE SET NULL ON UPDATE RESTRICT,</p>
<p>CONSTRAINT <code>OID</code> FOREIGN KEY (<code>OID</code>) REFERENCES <code>order</code> (<code>OID</code>) ON DELETE SET NULL ON UPDATE RESTRICT</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p><strong>Seat</strong></p>
<p>DROP TABLE IF EXISTS <code>seat</code>;</p>
<p>CREATE TABLE <code>seat</code> (</p>
<p><code>SID</code> int(3) NOT NULL,</p>
<p><code>Anum</code> int(2) NOT NULL,</p>
<p><code>State</code> int(1) NOT NULL,</p>
<p>PRIMARY KEY (<code>SID</code>) USING BTREE</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p><strong>User</strong></p>
<p>DROP TABLE IF EXISTS <code>user</code>;</p>
<p>CREATE TABLE <code>user</code> (</p>
<p><code>UID</code> int(10) NOT NULL,</p>
<p><code>UName</code> varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</p>
<p><code>Password</code> varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</p>
<p><code>Tele</code> char(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</p>
<p><code>Point</code> int(20) UNSIGNED NULL DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>UID</code>) USING BTREE</p>
<p>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<h1 id="6-结束语">6    结束语</h1>
<p>此次开发使我能够熟练的使用WindowBuilder进行GUI窗口设计，能够熟练的使用面向对象的思想进行Java程序的开发，并且学会了JDBC能够使用JAVA程序对数据库进行增删改查，还加强了对SQL语句的熟练程度，能够快速的对数据库进行操作。</p>
<p>我所开发的饭店管理系统以对用户端的体验为开发方向着重开发，当用户进行点餐时，仅仅进行单击操作就可以完整的进行选座，选餐，支付这一整套就餐步骤，极大的提升了用户体验；但由于时间关系在管理端还存在未开发完毕的功能，在时间充沛的情况下我会进行改进，并且以后提高自己的开发速度以避免再次出现这种情况。</p>
<h1 id="7-参考文献">7    参考文献</h1>
<p>[1]张海藩,牟永敏. 软件工程导论[M] .北京.清华大学出版社. 2013(06)</p>
<p>[2]耿祥义,张跃平. Java程序设计精编教程[M] .北京.清华大学出版社. 2017(03)</p>
<p>[3]王珊,萨师煊. 数据库系统概论[M].北京.高等教育出版社. 2014(05)</p>
<p>[4] 张英,杜炜. JDBC数据库连接池技术简介及设计[J]. 电脑知识与技术. 2010 (08)</p>
<p>[6] 赵海龙,戴玉刚. JDBC驱动程序及其选择分析[J]. 福建电脑. 2008 (02)</p>
<p>[7] 罗荣,唐学兵. 基于JDBC的数据库连接池的设计与实现[J]. 计算机工程. 2004 (09)</p>
<p>[8] 何明,戴钢,葛正义. 基于JDBC语句分享的数据库连接池[J]. 铁路计算机应用. 2002 (11)</p>
<p>[9] 张廷玉,石伟伟. 基于JDBC的WebGIS异构数据库存取技术[J]. 测绘通报. 2000 (01)</p>
<p>[10] 谢人强. 选用合适的JDBC驱动程序[J]. 电脑知识与技术(学术交流). 2007 (02)</p>
<p>[11] 孙国志. 面向软件工程的工作流管理系统研究[J]. 企业技术开发. 2014 (11)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在deepin中使用code::blocks]]></title>
        <id>https://DDC777.github.io/post/zai-deepin-zhong-shi-yong-codeblocks/</id>
        <link href="https://DDC777.github.io/post/zai-deepin-zhong-shi-yong-codeblocks/">
        </link>
        <updated>2020-10-28T13:45:06.000Z</updated>
        <summary type="html"><![CDATA[<p><s>记一次无用的折腾</s></p>
]]></summary>
        <content type="html"><![CDATA[<p><s>记一次无用的折腾</s></p>
<!-- more -->
<h3 id="安装codeblocks">安装code::blocks</h3>
<p><code>sudo add-apt-repository ppa:codeblocks-devs/release</code><br>
<code>sudo apt-get update</code><br>
<code>sudo apt-get install codeblocks codeblocks-contrib</code></p>
<p>若因为依赖安装失败，可通过aptitude安装</p>
<p><code>sudo apt-get install aptitude</code><br>
<code>sudo aptitude install codeblocks codeblocks-contrib</code></p>
<p>还是安装失败的话试试切换aptitude的不同安装方案</p>
<!-- more -->
<h3 id="安装环境变量">安装环境变量</h3>
<p><code>sudo apt-get install gcc</code></p>
<!-- more -->
<h3 id="汉化选装">汉化（选装）</h3>
<p>创建中文目录</p>
<p><code>cd /usr/share/codeblocks/</code><br>
<code>sudo mkdir locale</code><br>
<code>cd locale</code><br>
<code>sudo mkdir zh_CN</code></p>
<p>语言包链接：https://pan.baidu.com/s/1yZsSk9ZFqVx7cn02nI6M_g<br>
提取码：DDC5</p>
<p>将mo后缀的语言包移动到/usr/share/codeblocks/locale/zh_CN</p>
<p>打开code::blocks点击Setting：EnvironmentSettings，View中勾选internationalization就可以选择刚刚装的汉化包了</p>
<!-- more -->
<h3 id="其它">其它</h3>
<p>无法编译的话记得将编译器设置为GUN GCC Compiler</p>
<figure data-type="image" tabindex="1"><img src="https://DDC777.github.io/post-images/1603892866298.png" alt="" loading="lazy"></figure>
<p>code::blocks自带的终端xterm非常反人类，可以将终端设置为deepin系统终端</p>
<figure data-type="image" tabindex="2"><img src="https://DDC777.github.io/post-images/1603892875014.png" alt="" loading="lazy"></figure>
<p>提示插件不兼容的话可以直接去目录将那个插件改名或者移动到其它地方<s>删除</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次西西批西区域赛]]></title>
        <id>https://DDC777.github.io/post/ji-yi-ci-xi-xi-pi-xi-qu-yu-sai/</id>
        <link href="https://DDC777.github.io/post/ji-yi-ci-xi-xi-pi-xi-qu-yu-sai/">
        </link>
        <updated>2020-10-11T07:20:31.000Z</updated>
        <content type="html"><![CDATA[<p>封装一张纸条-&gt;ac一道题<br>
什么嘛，我还是蛮不错的嘛</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[针不戳]]></title>
        <id>https://DDC777.github.io/post/zhen-bu-cuo/</id>
        <link href="https://DDC777.github.io/post/zhen-bu-cuo/">
        </link>
        <updated>2020-09-10T13:06:22.000Z</updated>
        <content type="html"><![CDATA[<p>住在山里针不戳</p>
]]></content>
    </entry>
</feed>